local IceHub = loadstring(game:HttpGet("https://gist.githubusercontent.com/Imperador950/8bdbe1c8003c3645d31ecc08dd6f4954/raw/d7ef405e38759ce397cf5be65babe2a2bc62c92a/Sla"))()
local MainUI = IceHub.CreateMain()

local Tab_House = MainUI:NewTab("House")
local House = Tab_House:NewSection("House")
local Tab_Avatar = MainUI:NewTab("Avatar")
local Avatar = Tab_Avatar:NewSection("Avatar")
local Tab_Car = MainUI:NewTab("Vehicles")
local Car = Tab_Car:NewSection("Vehicles")
local Tab_Fun = MainUI:NewTab("Fun")
local Fun = Tab_Fun:NewSection("Fun")
local Tab_Itens = MainUI:NewTab("Build")
local Itens = Tab_Itens:NewSection("Build")
local Tab_Tools = MainUI:NewTab("Tools")
local Tools = Tab_Tools:NewSection("Tools")
local Tab_Map = MainUI:NewTab("Map")
local Map = Tab_Map:NewSection("Map")
local Tab_Visual = MainUI:NewTab("Visual")
local Visual = Tab_Visual:NewSection("Visual")
local Tab_Premium = MainUI:NewTab("Premium")
local Premium = Tab_Premium:NewSection("Premium")
local Tab_Others = MainUI:NewTab("Others")
local Others = Tab_Others:NewSection("Others")
local Tab_Teleportes = MainUI:NewTab("Teleport")
local Teleportes = Tab_Teleportes:NewSection("Teleport")
local Tab_Misc = MainUI:NewTab("Misc")
local Misc = Tab_Misc:NewSection("Misc")
local Tab_Kill = MainUI:NewTab("Kill")
local Kill = Tab_Kill:NewSection("Kill")
local Tab_Codes = MainUI:NewTab("Reward Codes")
local Codes = Tab_Codes:NewSection("Codes")
local Tab_Scripts = MainUI:NewTab("Scripts")
local Scripts = Tab_Scripts:NewSection("Scripts")

House:NewLabel("House Bio")

House:NewTextBox("Bio Text", "", function(value)
     args = {
        [1] = "BusinessName",
        [2] = value
    }
    game:GetService("ReplicatedStorage").RE["1RPHous1eEven1t"]:FireServer(unpack(args))
end)

local rainbowConnection
local running = false

House:NewToggle("Rainbow House Bio", function(state)
    if state then
        running = true
        rainbowConnection = task.spawn(function()
            while running do
                local success, errorMessage = pcall(function()
                    local players = game:GetService("Players")
                    local replicatedStorage = game:GetService("ReplicatedStorage")
                    local localPlayer = players.LocalPlayer
                    local colorEvent = replicatedStorage:WaitForChild("RE"):WaitForChild("1RPHous1eEven1tColo1r")
                    local colorFrames = localPlayer.PlayerGui.MainGUIHandler.HouseControl.HomeBus.HomeText.Picks.Frame:GetChildren()
                    local numColors = #colorFrames
                    
                    for i = 1, numColors do
                        if not running then break end -- parada segura no meio do processo
                        local colorFrame = colorFrames[i]
                        if colorFrame and colorFrame:IsA("GuiObject") and colorFrame:FindFirstChild("Color") then
                             args = {
                                [1] = "PickingBusinessNameColor",
                                [2] = colorFrame.Color
                            }
                            colorEvent:FireServer(unpack(args))
                            task.wait(0.7)
                        end
                    end
                    
                    task.wait(1)
                end)

                if not success then
                    warn("Error in Rainbow House Bio loop:", errorMessage)
                    task.wait(5)
                end
            end
        end)
    else
        running = false
    end
end)

House:NewLabel("House Design")

local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Remote = ReplicatedStorage.RE:FindFirstChild("1Player1sHous1e")
local runningRainbow = false

-- Duração da transição em segundos
local duration = 3 

-- Função para gerar uma cor aleatória suave (menos saturada)
local function getRandomColor()
    local r = math.random(50, 255) / 255
    local g = math.random(50, 255) / 255
    local b = math.random(50, 255) / 255
    return Color3.new(r, g, b)
end

-- Interpolação linear entre duas cores (lerp)
local function lerpColor(a, b, t)
    local r = a.R + (b.R - a.R) * t
    local g = a.G + (b.G - a.G) * t
    local b = a.B + (b.B - a.B) * t
    return Color3.new(r, g, b)
end

local function smoothColorTransition()
    local currentColor = getRandomColor()
    local targetColor = getRandomColor()

    while runningRainbow do
        local startTime = tick()
        while tick() - startTime < duration do
            if not runningRainbow then return end
            local elapsed = tick() - startTime
            local alpha = elapsed / duration
            local newColor = lerpColor(currentColor, targetColor, alpha)

            Remote:FireServer("ColorPickHouse", newColor)

            task.wait(0.1)
        end

        currentColor = targetColor
        targetColor = getRandomColor()
    end
end

-- Assumindo que House é um objeto que cria toggles na sua UI
House:NewToggle("Rainbow House", function(state)
    runningRainbow = state
    if state then
        task.spawn(smoothColorTransition)
    end
end)

House:NewLabel("House Settings")

local SelectHouse
local SelectedPlayerName

 function GetExistentHouses()
	local houseTable = {}
	for _, v in pairs(workspace["001_Lots"]:GetChildren()) do
		if string.find(v.Name, "House") and v:FindFirstChild("HousePickedByPlayer") then
			table.insert(houseTable, {
				FullName = v.Owner.Value,
				HouseNumber = v.Number.Number.Value,
				Model = v
			})
		end
	end
	return houseTable
end

 function FindHouseByPartialName(partialName)
	partialName = partialName:lower()
	for _, data in pairs(GetExistentHouses()) do
		if string.find(data.FullName:lower(), partialName) then
			return data
		end
	end
end

    House:NewTextBox("Target Player", "", function(txt)
		local result = FindHouseByPartialName(txt)
		if result then
			SelectHouse = result.HouseNumber
			SelectedPlayerName = result.FullName
			warn("[+]", "Found: " .. SelectedPlayerName .. " - House #" .. SelectHouse)
		else
			SelectHouse = nil
			SelectedPlayerName = nil
			warn("[-]", "No matching house found")
		end
	end)

House:NewButton("Teleport to the house", function()
		if not SelectHouse then return end
		for _, v in pairs(workspace["001_Lots"]:GetChildren()) do
			if v.Name ~= "DontDelete" and v.Number.Number.Value == SelectHouse then
				game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(v.WorldPivot.Position)
				break
			end
		end
	end)

House:NewButton("Teleport to the vault", function()
		if not SelectHouse then return end
		for _, v in pairs(workspace["001_Lots"]:GetChildren()) do
			if v.Name ~= "DontDelete" and v.Number.Number.Value == SelectHouse then
				local safe = v.HousePickedByPlayer.HouseModel["001_Safe"]
				game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(safe.WorldPivot.Position)
				break
			end
		end
	end)

House:NewToggle("Noclip through the house door", function(Value)
		if not SelectHouse then return end
		for _, v in pairs(workspace["001_Lots"]:GetChildren()) do
			if v.Name ~= "DontDelete" and v.Number.Number.Value == SelectHouse then
				pcall(function()
					local doors = v.HousePickedByPlayer.HouseModel["001_HouseDoors"].HouseDoorFront:GetChildren()
					for _, part in pairs(doors) do
						if part:IsA("BasePart") then
							part.CanCollide = not Value
						end
					end
				end)
				break
			end
		end
	end)

House:NewToggle("Spam Bell", function(Value)
		getgenv().ChaosHubAutoSpawnDoorbellValue = Value
		task.spawn(function()
			while getgenv().ChaosHubAutoSpawnDoorbellValue do
				if not SelectHouse then break end
				for _, v in pairs(workspace["001_Lots"]:GetChildren()) do
					if v.Name ~= "DontDelete" and v.Number.Number.Value == SelectHouse then
						fireclickdetector(v.HousePickedByPlayer.HouseModel["001_DoorBell"].TouchBell.ClickDetector)
						break
					end
				end
				task.wait(0.5)
			end
		end)
	end)

House:NewToggle("Spam Knock", function(Value)
		getgenv().ShnmaxAutoSpawnDoorValue = Value
		task.spawn(function()
			while getgenv().ShnmaxAutoSpawnDoorValue do
				if not SelectHouse then break end
				for _, v in pairs(workspace["001_Lots"]:GetChildren()) do
					if v.Name ~= "DontDelete" and v.Number.Number.Value == SelectHouse then
						fireclickdetector(v.HousePickedByPlayer.HouseModel["001_HouseDoors"].HouseDoorFront.Knock.TouchBell.ClickDetector)
						break
					end
				end
				task.wait(0.5)
			end
		end)
	end)

House:NewLabel("House Settings Player")

House:NewButton("House Fire", function()
 args = {
    [1] = "PlayerWantsFireOnFirePassNotShowingAnyone"
}

game:GetService("ReplicatedStorage").RE:FindFirstChild("1Player1sHous1e"):FireServer(unpack(args))
  	end)

local loopTravaPorta = false
local Remote = game:GetService("ReplicatedStorage").RE:FindFirstChild("1Player1sHous1e")

local function portaLoop()
    while loopTravaPorta do
         args = { [1] = "LockDoors" }
        Remote:FireServer(unpack(args))
        wait(1.5) -- intervalo entre trava/destrava (ajustável)
    end
end

House:NewToggle("Spam Door Lock", function(state)
    loopTravaPorta = state
    if state then
        spawn(portaLoop)
    end
end)

local poolLoopAtivo = false
local Remote = game:GetService("ReplicatedStorage").RE:FindFirstChild("1Player1sHous1e")

local function poolLoop()
    while poolLoopAtivo do
         args = { [1] = "PoolOnOff" }
        Remote:FireServer(unpack(args))
        wait(2) -- tempo entre liga/desliga (ajustável)
    end
end

House:NewToggle("Spam Pool", function(state)
    poolLoopAtivo = state
    if state then
        spawn(poolLoop)
    end
end)

local runningGarage = false
House:NewToggle("Spam Garage", function(state)
    runningGarage = state
    if state then
        spawn(function()
            while runningGarage do
                game:GetService("ReplicatedStorage").RE:FindFirstChild("1Player1sHous1e"):FireServer("GarageDoor")
                wait(0.5)
            end
        end)
        print("Loop Garagem ON")
    else
        print("Loop Garagem OFF")
    end
end)

-- Loop Cortinas
local runningCurtains = false
House:NewToggle("Spam Curtains", function(state)
    runningCurtains = state
    if state then
        spawn(function()
            while runningCurtains do
                game:GetService("ReplicatedStorage").RE:FindFirstChild("1Player1sHous1e"):FireServer("Curtains")
                wait(0.5)
            end
        end)
        print("Loop Cortinas ON")
    else
        print("Loop Cortinas OFF")
    end
end)

local runningBaby = false
House:NewToggle("Spam Baby Stuff", function(state)
    runningBaby = state
    if state then
        spawn(function()
            while runningBaby do
                game:GetService("ReplicatedStorage").RE:FindFirstChild("1Player1sHous1e"):FireServer("BabyOptionYes")
                wait(0.5)
                game:GetService("ReplicatedStorage").RE:FindFirstChild("1Player1sHous1e"):FireServer("BabyOptionNo")
                wait(0.5)
            end
        end)
        print("Loop Bebês ON")
    else
        print("Loop Bebês OFF")
    end
end)

House:NewButton("Unban", function()
    for _, v in pairs(game:GetService("Workspace"):WaitForChild("001_Lots"):GetDescendants()) do
        if v:IsA("BasePart") and string.match(v.Name, "^BannedBlock%d+") then
            v:Destroy()
        end
    end
end)

House:NewToggle("Auto Unban", function(state)
isUnbanActive = state
        if isUnbanActive then
            print("Auto Unban Activated")
            startAutoUnban()
        else
            print("Auto Unban Deactivated")
        end
    end)

function startAutoUnban()
    while isUnbanActive do
        for i, v in pairs(game:GetService("Workspace"):WaitForChild("001_Lots"):GetDescendants()) do
            -- houses
            if v.Name == "BannedBlock1" or v.Name == "BannedBlock2" or v.Name == "BannedBlock3" or v.Name == "BannedBlock4" or v.Name == "BannedBlock5" or v.Name == "BannedBlock6" or v.Name == "BannedBlock7" or v.Name == "BannedBlock11" or v.Name == "BannedBlock12" or v.Name == "BannedBlock13" or v.Name == "BannedBlock14" or v.Name == "BannedBlock15" or v.Name == "BannedBlock16" or v.Name == "BannedBlock17" or v.Name == "BannedBlock18" or v.Name == "BannedBlock19" or v.Name == "BannedBlock20" or v.Name == "BannedBlock21" or v.Name == "BannedBlock21" or v.Name == "BannedBlock22" or v.Name == "BannedBlock23" or v.Name == "BannedBlock24" or v.Name == "BannedBlock30" or v.Name == "BannedBlock31" or v.Name == "BannedBlock32" or v.Name == "BannedBlock33" or v.Name == "BannedBlock34" or v.Name == "BannedBlock35" then                -- destroy
                v:Destroy()
            end
        end
        wait(1) -- Espera 5 segundos antes de repetir a verificação
    end
end

local savedBannedBlocks = {}

House:NewToggle("Anti Ban Block", function(state)
    local lots = game:GetService("Workspace"):WaitForChild("001_Lots")

    if state then
        for _, v in pairs(lots:GetDescendants()) do
            if v:IsA("BasePart") and string.match(v.Name, "^BannedBlock%d+") then
                local clone = v:Clone()
                clone.Parent = nil
                table.insert(savedBannedBlocks, {block = clone, originalParent = v.Parent})
                v:Destroy()
            end
        end
    else
        for _, data in ipairs(savedBannedBlocks) do
            local clone = data.block:Clone()
            clone.Parent = data.originalParent
        end
        savedBannedBlocks = {}
    end
end)

Avatar:NewLabel("Normal Name")
Avatar:NewTextBox("RP Name", "", function(value)
 args = {
[1] = "RolePlayName", [2] = value

}
game:GetService("ReplicatedStorage").RE:FindFirstChild("1RPNam1eTex1t"):FireServer(unpack(args))
    end)

Avatar:NewLabel("Normal Bio")
Avatar:NewTextBox("RP Bio", "", function(value)
 args = {
[1] = "RolePlayBio", [2] = value

}
game:GetService("ReplicatedStorage").RE:FindFirstChild("1RPNam1eTex1t")
    end)

Avatar:NewLabel("FE Avatar Copier")

local Players = game:GetService("Players")
local Rep = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer
local lastValidTarget = nil
local copyType = "Brookhaven"
local Target = nil

-- Função utilitária
local function Wear(id)
    pcall(function()
        Rep.Remotes.Wear:InvokeServer(tonumber(id))
    end)
end

local function RESETBLOCK()
     args = {
        [1] = {0, 0, 0, 0, 0, 0},
        [2] = "AllBlocky"
    }
    pcall(function()
        Rep.Remotes.ChangeCharacterBody:InvokeServer(unpack(args))
    end)
end

local function ApplySkinToneFromUserId(userId)
    pcall(function()
        local info = Players:GetCharacterAppearanceInfoAsync(userId)
        if info.bodyColors then
            local headColor = info.bodyColors.HeadColor
            if headColor then
                Rep.Remotes.ChangeBodyColor:FireServer(tostring(headColor))
            end
        end
    end)
end

local function CopyClothing(desc)
    local items = {desc.Shirt, desc.Pants, desc.GraphicTShirt, desc.Face}
    for _, id in ipairs(items) do
        if tonumber(id) and id ~= 0 then
            Wear(id)
            task.wait(0.1)
        end
    end
end

local function CopyAccessories(desc)
    pcall(function()
        for _, v in ipairs(desc:GetAccessories(true)) do
            if v.AssetId then
                Wear(v.AssetId)
                task.wait(0.1)
            end
        end
    end)
end

local function CopyBodyParts(desc, source)
     args = {
        [1] = {
            tonumber(desc.Torso),
            tonumber(desc.RightArm),
            tonumber(desc.LeftArm),
            tonumber(desc.RightLeg),
            tonumber(desc.LeftLeg),
            tonumber(desc.Head)
        },
        [2] = source
    }
    pcall(function()
        Rep.Remotes.ChangeCharacterBody:InvokeServer(unpack(args))
    end)
end

local function CopyAnimations(desc)
    local anims = {
        desc.IdleAnimation,
        desc.WalkAnimation,
        desc.RunAnimation,
        desc.JumpAnimation,
        desc.FallAnimation,
        desc.SwimAnimation
    }
    for _, animId in ipairs(anims) do
        if tonumber(animId) and animId ~= 0 then
            Wear(animId)
            task.wait(0.1)
        end
    end
end

local function CopyBrookhaven(targetPlayer)
    local humanoid = targetPlayer.Character and targetPlayer.Character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end
    local desc = humanoid:GetAppliedDescription()
    local bodyColors = targetPlayer.Character:FindFirstChildOfClass("BodyColors")
    if bodyColors then
        local headColor = bodyColors.HeadColor
        if headColor then
            Rep.Remotes.ChangeBodyColor:FireServer(tostring(headColor))
        end
    end
    pcall(function()
        CopyAccessories(LocalPlayer.Character:FindFirstChildOfClass("Humanoid"):GetAppliedDescription())
        RESETBLOCK()
        CopyAccessories(desc)
        task.wait(0.1)
        CopyBodyParts(desc, "ShnmaxHub")
        CopyClothing(desc)
        CopyAnimations(desc)
    end)
end

local function CopyOriginalAvatar(userId)
    pcall(function()
        local desc = Players:GetHumanoidDescriptionFromUserId(userId)
        CopyAccessories(LocalPlayer.Character:FindFirstChildOfClass("Humanoid"):GetAppliedDescription())
        RESETBLOCK()
        CopyAccessories(desc)
        task.wait(0.1)
        CopyBodyParts(desc, "ShnmaxHub")
        CopyClothing(desc)
        CopyAnimations(desc)
        ApplySkinToneFromUserId(userId)
    end)
end

local function findPlayerByName(partialName)
    if not partialName or partialName == "" then return nil end
    partialName = partialName:lower()
    local foundPlayers = {}
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Name:lower():find(partialName, 1, true) then
            table.insert(foundPlayers, player)
        end
    end
    table.sort(foundPlayers, function(a, b)
        local aStart = a.Name:lower():sub(1, #partialName) == partialName
        local bStart = b.Name:lower():sub(1, #partialName) == partialName
        if aStart and not bStart then return true end
        if not aStart and bStart then return false end
        return #a.Name < #b.Name
    end)
    return foundPlayers[1]
end

-- UI Setup
Avatar:NewTextBox("Target Player", "type name..", function(text)
    if text == "" then
        if lastValidTarget then
            text = lastValidTarget
        else
            return
        end
    end
    local targetPlayer = findPlayerByName(text)
    if targetPlayer then
        Target = targetPlayer
        lastValidTarget = targetPlayer.Name
    end
end)

Avatar:NewDropdown("Copy Meathod", {"Brookhaven", "Original Avatar"}, function(option)
    copyType = option
end)

Avatar:NewButton("Copy Avatar", function()
    if not Target then return end
    if copyType == "Brookhaven" then
        CopyBrookhaven(Target)
    else
        CopyOriginalAvatar(Target.UserId)
    end
end)

Avatar:NewButton("Copy Avatar Nearest", function()
    local closest, dist = nil, math.huge
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local mag = (player.Character.HumanoidRootPart.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
            if mag < dist then
                closest = player
                dist = mag
            end
        end
    end
    if closest then
        if copyType == "Brookhaven" then
            CopyBrookhaven(closest)
        else
            CopyOriginalAvatar(closest.UserId)
        end
    end
end)

Avatar:NewButton("Copy Avatar Random", function()
    local candidates = {}
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            table.insert(candidates, player)
        end
    end
    if #candidates > 0 then
        local target = candidates[math.random(1, #candidates)]
        if copyType == "Brookhaven" then
            CopyBrookhaven(target)
        else
            CopyOriginalAvatar(target.UserId)
        end
    end
end)
    
Avatar:NewLabel("Avatar Section")

Avatar:NewButton("Old R6 Animation", function()
 loadstring(game:HttpGet('https://pastebin.com/raw/2cQWFs07'))()
end)

Avatar:NewButton("Old R15 Animation", function()
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")

-- Parar e remover todas as animações ativas
for _, track in ipairs(humanoid:GetPlayingAnimationTracks()) do
track:Stop()
track:Destroy()
end

-- Remover objetos Animation de dentro do personagem
for _, descendant in ipairs(character:GetDescendants()) do
if descendant:IsA("Animation") then
descendant:Destroy()
end
end

-- Forçar remoção de AnimationId em objetos suspeitos
for _, obj in ipairs(character:GetDescendants()) do
if obj:IsA("Tool") or obj:IsA("LocalScript") or obj:IsA("ModuleScript") then
for _, child in ipairs(obj:GetDescendants()) do
if child:IsA("Animation") then
child:Destroy()
end
end
end
end
end)

Avatar:NewLabel("Job Section")

local ChangeJobLoopEnabled = false

local function changeJobLoop()
while ChangeJobLoopEnabled do
args = {
[1] = "Dancer"
}

game:GetService("ReplicatedStorage").Remotes.GiveJobUIMenu:FireServer(unpack(args))
wait(0,5)
args = {
[1] = "Grocery Store"
}

game:GetService("ReplicatedStorage").Remotes.GiveJobUIMenu:FireServer(unpack(args))
wait(0,5)
args = {
[1] = "Police"
}

game:GetService("ReplicatedStorage").Remotes.GiveJobUIMenu:FireServer(unpack(args))
wait(0,5)
args = {
[1] = "Hospital"
}

game:GetService("ReplicatedStorage").Remotes.GiveJobUIMenu:FireServer(unpack(args))
wait(0,5)
args = {
[1] = "Fire House"
}

game:GetService("ReplicatedStorage").Remotes.GiveJobUIMenu:FireServer(unpack(args))
wait(0,5)
args = {
[1] = "Teacher"
}

game:GetService("ReplicatedStorage").Remotes.GiveJobUIMenu:FireServer(unpack(args))
wait(0,5)
args = {
[1] = "Student"
}

game:GetService("ReplicatedStorage").Remotes.GiveJobUIMenu:FireServer(unpack(args))
wait(0,5)
args = {
[1] = "Bank"
}

game:GetService("ReplicatedStorage").Remotes.GiveJobUIMenu:FireServer(unpack(args))
wait(0,5)
args = {
[1] = "S.W.A.T."
}

game:GetService("ReplicatedStorage").Remotes.GiveJobUIMenu:FireServer(unpack(args))
end
end

Avatar:NewToggle("Loop Jobs", function(Value)
if Value then
ChangeJobLoopEnabled = true
changeJobLoop()
else
ChangeJobLoopEnabled = false
end
end)

Avatar:NewLabel("Character Settings")

local StarterGui = game:GetService("StarterGui")
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

local function getHumanoid()
character = player.Character or player.CharacterAdded:Wait()
return character:FindFirstChildOfClass("Humanoid")
end

local function notify(title, text, duration)
StarterGui:SetCore("SendNotification", {
Title = title,
Text = text,
Duration = duration or 3
})
end

Avatar:NewTextBox("Speed", "", function(text)
local value = tonumber(text)
local humanoid = getHumanoid()
if humanoid and value then
humanoid.WalkSpeed = value
notify("Velocidade Alterada", "Nova velocidade: " .. value)
else
warn("Valor inválido para velocidade")
notify("Erro", "Valor inválido para velocidade")
end
end)

Avatar:NewTextBox("Jump", "", function(text)
local value = tonumber(text)
local humanoid = getHumanoid()
if humanoid and value then
humanoid.JumpPower = value
notify("Salto Alterado", "Novo salto: " .. value)
else
warn("Valor inválido para salto")
notify("Erro", "Valor inválido para salto")
end
end)

Avatar:NewButton("Reset Walkspeed/Jumppower", function()
local humanoid = getHumanoid()
if humanoid then
humanoid.WalkSpeed = 16
humanoid.JumpPower = 50
notify("Valores Restaurados", "Velocidade e salto padrão aplicados.")
else
warn("Humanoid não encontrado!")
notify("Erro", "Humanoid não encontrado!")
end
end)

Avatar:NewButton("Refresh Avatar", function()
game:GetService("ReplicatedStorage").Remotes.ResetCharacterAppearance:FireServer()
end)

Avatar:NewButton("Reset 1", function()
local character = game.Players.LocalPlayer.Character
local humanoid = character:FindFirstChild("Humanoid")

for _, part in pairs(character:GetChildren()) do  
	if part:IsA("Part") or part:IsA("BasePart") or part:IsA("MeshPart") then  
		if part.Anchored then  
			part.Anchored = false  
		end  
	end  
end  

if humanoid then  
	humanoid.Health = 0  
end

end)

Avatar:NewButton("Reset 2", function()
local character = game.Players.LocalPlayer.Character
if not character then return end

for _, part in pairs(character:GetChildren()) do  
	if part:IsA("Part") or part:IsA("BasePart") or part:IsA("MeshPart") then  
		if part.Anchored then  
			part.Anchored = false  
		end  
	end  
end  

local upperTorso = character:FindFirstChild("UpperTorso")  
if upperTorso then  
	upperTorso:Destroy()  
end

end)

Avatar:NewLabel("Character Appearance")

Avatar:NewButton("Fire Avatar", function()
local player = game.Players.LocalPlayer
local character = player.Character
if not character then return end

local house = workspace:FindFirstChild("001_Lots") and workspace["001_Lots"]:FindFirstChild(player.Name .. "House")  
local mall = house  
	and house:FindFirstChild("HousePickedByPlayer")  
	and house.HousePickedByPlayer:FindFirstChild("HouseModel")  
	and house.HousePickedByPlayer.HouseModel:FindFirstChild("001_BBQ")  
	and house.HousePickedByPlayer.HouseModel["001_BBQ"]:FindFirstChild("CatchFire")  

local hrp = character:FindFirstChild("HumanoidRootPart")  

if mall and hrp then  
	firetouchinterest(hrp, mall, 0)  
	task.wait()  
	firetouchinterest(hrp, mall, 1)  
end

end)

local FireLoopAtivo = false

local function toggleFireLoop(ativo)
FireLoopAtivo = ativo
notify("Loop Fire", ativo and "Ativado" or "Desativado")

if ativo then  
    task.spawn(function()  
        while FireLoopAtivo do  
            local house = Workspace:FindFirstChild("001_Lots") and Workspace["001_Lots"]:FindFirstChild(player.Name .. "House")  
            local mall = house and house:FindFirstChild("HousePickedByPlayer") and house.HousePickedByPlayer:FindFirstChild("HouseModel"):FindFirstChild("001_BBQ"):FindFirstChild("CatchFire")  
            local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")  
            if mall and hrp then  
                firetouchinterest(hrp, mall, 0)  
                task.wait()  
                firetouchinterest(hrp, mall, 1)  
            end  
            task.wait(1)  
        end  
    end)  
end

end

Avatar:NewToggle("Loop Fire Avatar", function(state)
toggleFireLoop(state)
end)

Avatar:NewButton("Smoke Avatar", function()
local mall = Workspace:FindFirstChild("WorkspaceCom") and Workspace.WorkspaceCom:FindFirstChild("001_Mall")
mall = mall and mall:FindFirstChild("001_Pizza") and mall["001_Pizza"]:FindFirstChild("CatchFire")
local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
if mall and hrp then
firetouchinterest(hrp, mall, 0)
task.wait()
firetouchinterest(hrp, mall, 1)
end
end)

local SmokeLoopAtivo = false

function toggleSmokeLoop(ativo)
SmokeLoopAtivo = ativo
notify("Loop Smoke", ativo and "Ativado" or "Desativado")

if ativo then  
    task.spawn(function()  
        while SmokeLoopAtivo do  
            local mall = Workspace:FindFirstChild("WorkspaceCom") and Workspace.WorkspaceCom:FindFirstChild("001_Mall")  
            mall = mall and mall:FindFirstChild("001_Pizza") and mall["001_Pizza"]:FindFirstChild("CatchFire")  
            local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")  
            if mall and hrp then  
                firetouchinterest(hrp, mall, 0)  
                task.wait()  
                firetouchinterest(hrp, mall, 1)  
            end  
            task.wait(1)  
        end  
    end)  
end

end

Avatar:NewToggle("Loop Smoke Avatar", function(state)
toggleSmokeLoop(state)
end)

Avatar:NewLabel("Body Section")
Avatar:NewButton("FE Faceless", function()
local head = game.Players.LocalPlayer.Character:WaitForChild("Head")
local face = head:FindFirstChildOfClass("Decal")
if face then
face.Texture = "rbxassetid://0"
end
end)

Avatar:NewButton("FE Naked", function()
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

local shirt = character:FindFirstChildOfClass("Shirt")  
if shirt then shirt:Destroy() end  

local pants = character:FindFirstChildOfClass("Pants")  
if pants then pants:Destroy() end

end)

Avatar:NewButton("Refresh Avatar", function()
game:GetService("ReplicatedStorage").Remotes.ResetCharacterAppearance:FireServer()
end)

Avatar:NewLabel("Custom Hats, Hairs, and some...")

Avatar:NewTextBox("Id Box", "", function(Value)
args = {
[1] = Value
}

game:GetService("ReplicatedStorage").Remotes.Wear:InvokeServer(unpack(args))
end)

Avatar:NewButton("Refresh Avatar", function()
game:GetService("ReplicatedStorage").Remotes.ResetCharacterAppearance:FireServer()
end)

Car:NewLabel("Target Car Player")

local Vehicles = workspace:FindFirstChild("Vehicles")
local Player = game.Players.LocalPlayer
local SelectCar

local Tabela = {}
if Vehicles then
    for _, car in ipairs(Vehicles:GetChildren()) do
        if car:IsA("Model") then
            table.insert(Tabela, car.Name)
        end
    end
end

local CarDropdown = Car:NewDropdown("Vehicle - ", Tabela, function(Value)
        SelectCar = Value
    end)

Car:NewButton("Teleport to Vehicle", function()
local Car = Vehicles:FindFirstChild(tostring(SelectCar))
  if Car then
    for _, basepart in ipairs(Car:GetDescendants()) do
      if basepart:IsA("BasePart") then
        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(basepart.Position)
      end
    end
  end
end)

Car:NewButton("Teleport to Seat", function()
    local Car = Vehicles:FindFirstChild(tostring(SelectCar))
    local Character = Player.Character
    if Car and Character then
        local Seat = Car:FindFirstChild("Body") and Car.Body:FindFirstChild("VehicleSeat") or Car:FindFirstChildWhichIsA("VehicleSeat")
        local RootPart = Character:FindFirstChild("HumanoidRootPart")

        if Seat and RootPart then
            RootPart.CFrame = Seat.CFrame + Vector3.new(0, 3, 0)
        end
    end
end)

Car:NewButton("Pull Vehicle", function()
        local Car = Vehicles:FindFirstChild(tostring(SelectCar))
        local Character = Player.Character
        if Car and Character then
            local Seat = Car:FindFirstChild("Body") and Car.Body:FindFirstChild("VehicleSeat")
            local Humanoid = Character:FindFirstChildOfClass("Humanoid")
            local RootPart = Character:FindFirstChild("HumanoidRootPart")

            if Seat and Humanoid and RootPart then
                if not Car.PrimaryPart then
                    local try = Car:FindFirstChild("Primary") or Car:FindFirstChildWhichIsA("BasePart")
                    if try then
                        Car.PrimaryPart = try
                    end
                end

                if Car.PrimaryPart then
                    local OldPos = RootPart.CFrame

                    repeat
                        task.wait()
                        RootPart.CFrame = Seat.CFrame
                    until Humanoid.Sit

                    task.wait(0.7)

                    Car:SetPrimaryPartCFrame(OldPos)
                end
            end
        end
    end)
    
Car:NewLabel("Tank Section")

local player = game:GetService("Players").LocalPlayer
local spamConns = {}

local function explode(car)
    local p = car:FindFirstChild("Body") and car.Body:FindFirstChild("BodyPanels")
    local s = p and p:FindFirstChild("Shoot")
    local cd = s and s:FindFirstChildOfClass("ClickDetector")
    if cd then fireclickdetector(cd) end
end

local function toggleSpam(type, enable)
    if spamConns[type] then
        spamConns[type]:Disconnect()
        spamConns[type] = nil
    end

    if not enable then return end

    spamConns[type] = game:GetService("RunService").Heartbeat:Connect(function()
        local v = workspace:FindFirstChild("Vehicles")
        if not v then return end

        for _, car in ipairs(v:GetChildren()) do
            if car:IsA("Model") then
                if type == "Own" and car.Name == player.Name .. "Car" then
                    explode(car)
                elseif type == "All" and car.Name ~= player.Name .. "Car" then
                    explode(car)
                end
            end
        end
    end)
end

Car:NewToggle("Spam Explode Tank", function(state)
    toggleSpam("Own", state)
end)

Car:NewToggle("Spam Explode Every Tank", function(state)
    toggleSpam("All", state)
end)

Car:NewLabel("Car Settings (Premium Only) ")
 
local runningCarRainbow = false
local RunService = game:GetService("RunService")
local carRemote = game:GetService("ReplicatedStorage").RE:FindFirstChild("1Player1sCa1r")

-- Reaproveita a função de gerar cores suaves
local function getRandomColor()
	local r = math.random(50, 255) / 255
	local g = math.random(50, 255) / 255
	local b = math.random(50, 255) / 255
	return Color3.new(r, g, b)
end

local function lerpColor(a, b, t)
	local r = a.R + (b.R - a.R) * t
	local g = a.G + (b.G - a.G) * t
	local b = a.B + (b.B - a.B) * t
	return Color3.new(r, g, b)
end

local function smoothCarColorTransition()
	local currentColor = getRandomColor()
	local targetColor = getRandomColor()
	local duration = 2.5 -- pode ajustar conforme feeling

	while runningCarRainbow do
		local startTime = tick()
		while tick() - startTime < duration do
			if not runningCarRainbow then return end
			local elapsed = tick() - startTime
			local alpha = elapsed / duration
			local newColor = lerpColor(currentColor, targetColor, alpha)

			carRemote:FireServer("PickingCarColor", newColor)

			task.wait(0.1)
		end

		currentColor = targetColor
		targetColor = getRandomColor()
	end
end

Car:NewToggle("Rainbow Car", function(state)
	runningCarRainbow = state
	if state then
		task.spawn(smoothCarColorTransition)
		print("Rainbow Car ativado.")
	else
		print("Rainbow Car desativado.")
	end
end)

Car:NewButton("Remove Wheel", function()
 args = {
    [1] = "BlowFrontLeft"
}

game:GetService("ReplicatedStorage").RE:FindFirstChild("1Player1sCa1r"):FireServer(unpack(args))
wait()
 args = {
    [1] = "BlowFrontRight"
}

game:GetService("ReplicatedStorage").RE:FindFirstChild("1Player1sCa1r"):FireServer(unpack(args))
wait()
 args = {
    [1] = "BlowRearRight"
}

game:GetService("ReplicatedStorage").RE:FindFirstChild("1Player1sCa1r"):FireServer(unpack(args))
wait() 
args = {
    [1] = "BlowRearLeft"
}

game:GetService("ReplicatedStorage").RE:FindFirstChild("1Player1sCa1r"):FireServer(unpack(args))
end)

Car:NewToggle("Spam Fire", function(state)
    runningFire = state
    if state then
        spawn(function()
            while runningFire do
                game:GetService("ReplicatedStorage").RE:FindFirstChild("1Player1sCa1r"):FireServer("Fire")
                wait(2)
            end
        end)
        print("Loop Fire ON")
    else
        print("Loop Fire OFF")
    end
end)

local runningDuke1 = false
Car:NewToggle("Spam Duke 1", function(state)
    runningDuke1 = state
    if state then
        spawn(function()
            while runningDuke1 do
                game:GetService("ReplicatedStorage").RE:FindFirstChild("1Player1sCa1r"):FireServer("Duke1")
                wait(1)
            end
        end)
        print("Loop Duke 1 ON")
    else
        print("Loop Duke 1 OFF")
    end
end)

-- Loop Duke 2
local runningDuke2 = false
Car:NewToggle("Spam Duke 2", function(state)
    runningDuke2 = state
    if state then
        spawn(function()
            while runningDuke2 do
                game:GetService("ReplicatedStorage").RE:FindFirstChild("1Player1sCa1r"):FireServer("Duke")
                wait(1)
            end
        end)
        print("Loop Duke 2 ON")
    else
        print("Loop Duke 2 OFF")
    end
end)

Car:NewToggle("Spam Turbo", function(state)
    runningSmoke = state
    if state then
        spawn(function()
            while runningSmoke do
                game:GetService("ReplicatedStorage").RE:FindFirstChild("1Player1sCa1r"):FireServer("Smoke")
                wait(2)
            end
        end)
        print("Loop Fire ON")
    else
        print("Loop Fire OFF")
    end
end)

function playCarMusic(musicId)
    if musicId and musicId ~= "" then
        carArgs = {
            [1] = "PickingCarMusicText",
            [2] = musicId
        }
        game:GetService("ReplicatedStorage").RE:FindFirstChild("1Player1sCa1r"):FireServer(unpack(carArgs))
    else
        print("Por favor, insira um ID de música válido.")
    end
end

function playScooterMusic(musicId)
    if musicId and musicId ~= "" then
         scooterArgs = {
            [1] = "PickingScooterMusicText",
            [2] = musicId
        }
        game:GetService("ReplicatedStorage"):WaitForChild("RE"):WaitForChild("1NoMoto1rVehicle1s"):FireServer(unpack(scooterArgs))
    else
        print("Por favor, insira um ID de música válido.")
    end
end

Car:NewTextBox("Car Music", "Enter id here...", function(value)
            playCarMusic(value)
            playScooterMusic(value)
        end)

Car:NewLabel("Car Settings (Free) ")

local Player = game.Players.LocalPlayer
local Vehicles = workspace:FindFirstChild("Vehicles")

 function ApplyValueToCar(value)
    local car = Vehicles and Vehicles:FindFirstChild(Player.Name .. "Car")
    if car then
        local seat = car:FindFirstChild("Body") and car.Body:FindFirstChild("VehicleSeat")
        if seat then
            seat.TopSpeed.Value = value
            seat.Turbo.Value = value

             args = {
                [1] = "DriftingNumber",
                [2] = value
            }
            game:GetService("ReplicatedStorage").RE:FindFirstChild("1Player1sCa1r"):FireServer(unpack(args))

            print("Speed =  " .. value)
        else
            print("Error sit in car first")
        end
    else
        print("Spawn a car first !")
    end
end

Car:NewTextBox("Speed Box", "Enter id here...", function(input)
        local num = tonumber(input)
        if num then
            ApplyValueToCar(num)
        else
            print("...")
        end
    end)
    
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local remote = ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Player1sCa1r")

-- Spam Horn
local hornActive = false
Car:NewToggle("Spam Horn", function(state)
    hornActive = state
    if state then
        spawn(function()
            while hornActive do
                remote:FireServer("Horn")
                wait(0.1)
            end
        end)
    end
end)

-- Spam Light
local lightActive = false
Car:NewToggle("Spam Light", function(state)
    lightActive = state
    if state then
        spawn(function()
            while lightActive do
                remote:FireServer("Lights")
                wait(0.4)
            end
        end)
    end
end)

-- Spam Hazards
local hazardActive = false
Car:NewToggle("Spam Hazards", function(state)
    hazardActive = state
    if state then
        spawn(function()
            while hazardActive do
                remote:FireServer("Hazards")
                wait(0.4)
            end
        end)
    end
end)

-- Spam Wheel
local wheelActive = false
Car:NewToggle("Spam Wheel", function(state)
    wheelActive = state
    if state then
        spawn(function()
            while wheelActive do
                remote:FireServer("WheelNumber")
                wait(0.4)
            end
        end)
    end
end)

-- Spam Height
local heightActive = false
Car:NewToggle("Spam Height", function(state)
    heightActive = state
    if state then
        spawn(function()
            while heightActive do
                remote:FireServer("VehicleHeight", 4)
                wait(1)
                remote:FireServer("VehicleHeight", 1)
                wait(1)
            end
        end)
    end
end)
    
Car:NewLabel("Bike Section")

local runningBikeRainbow = false
local bikeRemote = game:GetService("ReplicatedStorage").RE:FindFirstChild("1Player1sCa1r")

-- Reutiliza função global se já existir
local function getRandomColor()
	local r = math.random(50, 255) / 255
	local g = math.random(50, 255) / 255
	local b = math.random(50, 255) / 255
	return Color3.new(r, g, b)
end

local function lerpColor(a, b, t)
	local r = a.R + (b.R - a.R) * t
	local g = a.G + (b.G - a.G) * t
	local b = a.B + (b.B - a.B) * t
	return Color3.new(r, g, b)
end

local function smoothBikeColorTransition()
	local currentColor = getRandomColor()
	local targetColor = getRandomColor()
	local duration = 2.5 -- ajuste de acordo com o efeito desejado

	while runningBikeRainbow do
		local startTime = tick()
		while tick() - startTime < duration do
			if not runningBikeRainbow then return end
			local elapsed = tick() - startTime
			local alpha = elapsed / duration
			local newColor = lerpColor(currentColor, targetColor, alpha)

			bikeRemote:FireServer("NoMotorColor", newColor)
			task.wait(0.1)
		end

		currentColor = targetColor
		targetColor = getRandomColor()
	end
end

Car:NewToggle("Rainbow Bike", function(state)
	runningBikeRainbow = state
	if state then
		print("Rainbow Bike ativado.")
		task.spawn(smoothBikeColorTransition)
	else
		print("Rainbow Bike desativado.")
	end
end)

Fun:NewLabel("Sign Section")
Fun:NewButton("Get Sign", function()
 args = {[1] = "PickingTools", [2] = "Sign"}		
	game:GetService("ReplicatedStorage").RE:FindFirstChild("1Too1l"):InvokeServer(unpack(args))
    game.Players.LocalPlayer.Backpack["Sign"].Parent = game.Players.LocalPlayer.Character
end)

 sign1 = ""
 sign2 = ""
 sign3 = ""
 sign4 = ""
 sign5 = ""
 repeatNames = false

Textbox = Fun:NewTextBox("Sign 1", "Enter text here...", function(value)
sign1 = value
end)
Textbox = Fun:NewTextBox("Sign 2", "Enter text here...", function(value)
sign2 = value
end)
Textbox = Fun:NewTextBox("Sign 3", "Enter text here...", function(value)
sign3 = value
end)
Textbox = Fun:NewTextBox("Sign 4", "Enter text here...", function(value)
sign4 = value
end)
Textbox = Fun:NewTextBox("Sign 5", "Enter text here...", function(value)
sign5 = value
end)

Fun:NewToggle("Validate", function(value)
repeatNames = value
while repeatNames do
args1 = {
    [1] = "Sign",
    [2] = "SignWords",
    [3] = sign1
}

game:GetService("Players").LocalPlayer.Character.Sign.ToolSound:FireServer(unpack(args1))
wait(0.2)
args2 = {
    [1] = "Sign",
    [2] = "SignWords",
    [3] = sign2
}

game:GetService("Players").LocalPlayer.Character.Sign.ToolSound:FireServer(unpack(args2))
wait(0.2)
args3 = {
    [1] = "Sign",
    [2] = "SignWords",
    [3] = sign3
}

game:GetService("Players").LocalPlayer.Character.Sign.ToolSound:FireServer(unpack(args3))
wait(0.2)
args4 = {
    [1] = "Sign",
    [2] = "SignWords",
    [3] = sign4
}

game:GetService("Players").LocalPlayer.Character.Sign.ToolSound:FireServer(unpack(args4))
wait(0.2)
args5 = {
    [1] = "Sign",
    [2] = "SignWords",
    [3] = sign5
}

game:GetService("Players").LocalPlayer.Character.Sign.ToolSound:FireServer(unpack(args5))
end
end)

Fun:NewLabel("Box Section")
Fun:NewButton("Get Box", function()
 args = {[1] = "PickingTools", [2] = "Box"}		
	game:GetService("ReplicatedStorage").RE:FindFirstChild("1Too1l"):InvokeServer(unpack(args))
    game.Players.LocalPlayer.Backpack["Box"].Parent = game.Players.LocalPlayer.Character
end)

 Box1 = ""
 Box2 = ""
 Box3 = ""
 Box4 = ""
 Box5 = ""
 repeatNames1 = false

Textbox = Fun:NewTextBox("Box 1", "Enter text here...", function(value)
Box1 = value
end)
Textbox = Fun:NewTextBox("Box 2", "Enter text here...", function(value)
Box2 = value
end)
Textbox = Fun:NewTextBox("Box 3", "Enter text here...", function(value)
Box3 = value
end)
Textbox = Fun:NewTextBox("Box 4", "Enter text here...", function(value)
Box4 = value
end)
Textbox = Fun:NewTextBox("Box 5", "Enter text here...", function(value)
Box5 = value
end)

Fun:NewToggle("Validate", function(value)
repeatNames1 = value
while repeatNames1 do
args1 = {
    [1] = "Box",
    [2] = "SignWords",
    [3] = Box1
}

game:GetService("Players").LocalPlayer.Character.Box.ToolSound:FireServer(unpack(args1))
wait(0.2)
args2 = {
    [1] = "Box",
    [2] = "SignWords",
    [3] = Box2
}

game:GetService("Players").LocalPlayer.Character.Box.ToolSound:FireServer(unpack(args2))
wait(0.2)
args3 = {
    [1] = "Box",
    [2] = "SignWords",
    [3] = Box3
}

game:GetService("Players").LocalPlayer.Character.Box.ToolSound:FireServer(unpack(args3))
wait(0.2)
args4 = {
    [1] = "Box",
    [2] = "SignWords",
    [3] = Box4
}

game:GetService("Players").LocalPlayer.Character.Box.ToolSound:FireServer(unpack(args4))
wait(0.2)
args5 = {
    [1] = "Box",
    [2] = "SignWords",
    [3] = Box5
}

game:GetService("Players").LocalPlayer.Character.Box.ToolSound:FireServer(unpack(args5))
end
end)

Fun:NewLabel("Roses Section")

-- ROSES SECTION
Fun:NewButton("Get Roses", function()
	 args = {"PickingTools", "Roses"}
	game:GetService("ReplicatedStorage").RE:FindFirstChild("1Too1l"):InvokeServer(unpack(args))

	local player = game.Players.LocalPlayer
	local rose = player.Backpack:FindFirstChild("Roses")
	if rose then
		rose.Parent = player.Character
	end
end)

local toggleActive = false

function RosesColor()
	task.spawn(function()
		while toggleActive do
			local char = game.Players.LocalPlayer.Character
			if not char then break end
			local rose = char:FindFirstChild("Roses")
			if not rose then break end
			local sound = rose:FindFirstChild("ToolSound")
			if not sound then break end

			local sounds = {
				"http://www.roblox.com/asset/?id=5210399458",
				"http://www.roblox.com/asset/?id=5210414520",
				"http://www.roblox.com/asset/?id=5216708760"
			}

			for _, id in ipairs(sounds) do
				if not toggleActive then break end
				sound:FireServer("Roses", id)
				task.wait(0.2)
			end
		end
	end)
end

Fun:NewToggle("Rainbow Roses", function(value)
	toggleActive = value
	if toggleActive then
		RosesColor()
	end
end)

-- UNIVERSAL TOOL COUNTER
local function CountTool(toolName)
	local player = game.Players.LocalPlayer
	local total = 0
	for _, tool in ipairs(player.Backpack:GetChildren()) do
		if tool.Name == toolName then
			total += 1
		end
	end
	for _, tool in ipairs(player.Character:GetChildren()) do
		if tool.Name == toolName then
			total += 1
		end
	end
	return total
end

-- UNIVERSAL TOOL DUPLICATOR
local function CreateDuplicator(toolName, labelName)
	Fun:NewLabel(labelName.." Section")

	local amount = 100

	Fun:NewTextBox("Amount", "", function(value)
		local number = tonumber(value)
		if number and number > 0 then
			amount = number
		else
			warn("Enter a valid number.")
		end
	end)

	Fun:NewButton("Dupe "..labelName, function()
		local player = game.Players.LocalPlayer
		local char = player.Character or player.CharacterAdded:Wait()
		local backpack = player:WaitForChild("Backpack")
		local root = char:WaitForChild("HumanoidRootPart")

		local giveTools = workspace:FindFirstChild("WorkspaceCom")
			and workspace.WorkspaceCom:FindFirstChild("001_GiveTools")
		local toolObject = giveTools and giveTools:FindFirstChild(toolName)

		if not (toolObject and toolObject:FindFirstChildOfClass("ClickDetector")) then
			warn("Tool not found in Workspace.")
			return
		end

		local detector = toolObject:FindFirstChildOfClass("ClickDetector")
		local oldPos = root.CFrame

		task.spawn(function()
			while CountTool(toolName) < amount do
				root.CFrame = toolObject.CFrame
				fireclickdetector(detector)
				task.wait(0.01)
			end
			root.CFrame = oldPos
			print("Duplication complete: "..toolName.." x"..CountTool(toolName))
		end)
	end)
end

-- CRIANDO CADA SEÇÃO COM MESMO SISTEMA
CreateDuplicator("Taser", "Taser")
CreateDuplicator("FireX", "FireX")
CreateDuplicator("Assault", "Gun")
CreateDuplicator("Basketball", "Balls")

-- BALLS LOOPER SECTION
local ThrowActive = false
local ThrowThread

Fun:NewToggle("Balls Looper", function(state)
	ThrowActive = state

	if state then
		local player = game.Players.LocalPlayer
		local mouse = player:GetMouse()
		local char = player.Character or player.CharacterAdded:Wait()

		if not (player and mouse and char) then
			warn("Missing player, mouse or character")
			return
		end

		ThrowThread = task.spawn(function()
			while ThrowActive do
				for _, tool in ipairs(char:GetChildren()) do
					if tool.Name == "Basketball" and tool:FindFirstChild("ClickEvent") then
						tool.ClickEvent:FireServer(mouse.Hit.p)
						task.wait(0.0003)
					end
				end
				task.wait()
			end
		end)
	else
		if ThrowThread then
			task.cancel(ThrowThread)
			ThrowThread = nil
		end
	end
end)

Fun:NewLabel("Fling Section")
Fun:NewButton("FE Fling DOORS", function()
    local Players = game:GetService("Players")
    local Workspace = game:GetService("Workspace")
    local RunService = game:GetService("RunService")
    local UserInputService = game:GetService("UserInputService")

    local LocalPlayer = Players.LocalPlayer
    local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local HRP = Character:WaitForChild("HumanoidRootPart")

    -- Alvo invisível (BlackHole)
    local BlackHole = Instance.new("Part")
    BlackHole.Size = Vector3.new(100000, 100000, 100000)
    BlackHole.Transparency = 1
    BlackHole.Anchored = true
    BlackHole.CanCollide = false
    BlackHole.Name = "BlackHoleTarget"
    BlackHole.Parent = Workspace

    -- Attachment base no BlackHole
    local baseAttachment = Instance.new("Attachment")
    baseAttachment.Name = "SHNMAX_BlackHoleAttachment"
    baseAttachment.Parent = BlackHole

    -- Atualiza posição do BlackHole
    RunService.Heartbeat:Connect(function()
        BlackHole.CFrame = HRP.CFrame
    end)

    -- Lista de portas controladas
    local ControlledDoors = {}

    -- Prepara uma porta para ser controlada
    local function SetupPart(part)
        if not part:IsA("BasePart") or part.Anchored or not string.find(part.Name, "Door") then return end
        if part:FindFirstChild("SHNMAX_Attached") then return end

        part.CanCollide = false

        for _, obj in ipairs(part:GetChildren()) do
            if obj:IsA("AlignPosition") or obj:IsA("Torque") or obj:IsA("Attachment") then
                obj:Destroy()
            end
        end

        local marker = Instance.new("BoolValue", part)
        marker.Name = "SHNMAX_Attached"

        local a1 = Instance.new("Attachment", part)

        local align = Instance.new("AlignPosition", part)
        align.Attachment0 = a1
        align.Attachment1 = baseAttachment
        align.MaxForce = 1e95
        align.MaxVelocity = math.huge
        align.Responsiveness = 999999

        local torque = Instance.new("Torque", part)
        torque.Attachment0 = a1
        torque.RelativeTo = Enum.ActuatorRelativeTo.World
        torque.Torque = Vector3.new(
            math.random(-10e5, 10e5) * 10000,
            math.random(-10e5, 10e5) * 10000,
            math.random(-10e5, 10e5) * 10000
        )

        table.insert(ControlledDoors, {Part = part, Align = align})
    end

    -- Detecta e prepara portas existentes
    for _, obj in ipairs(Workspace:GetDescendants()) do
        if obj:IsA("BasePart") and string.find(obj.Name, "Door") then
            SetupPart(obj)
        end
    end

    -- Novas portas no futuro
    Workspace.DescendantAdded:Connect(function(obj)
        if obj:IsA("BasePart") and string.find(obj.Name, "Door") then
            SetupPart(obj)
        end
    end)

    -- Flinga jogador com timeout e retorno
    local function FlingPlayer(player)
        local char = player.Character
        if not char then return end
        local targetHRP = char:FindFirstChild("HumanoidRootPart")
        if not targetHRP then return end

        local targetAttachment = targetHRP:FindFirstChild("SHNMAX_TargetAttachment")
        if not targetAttachment then
            targetAttachment = Instance.new("Attachment", targetHRP)
            targetAttachment.Name = "SHNMAX_TargetAttachment"
        end

        for _, data in ipairs(ControlledDoors) do
            if data.Align then
                data.Align.Attachment1 = targetAttachment
            end
        end

        local start = tick()
        local flingDetected = false

        while tick() - start < 5 do
            if targetHRP.Velocity.Magnitude >= 20 then
                flingDetected = true
                break
            end
            RunService.Heartbeat:Wait()
        end

        -- Sempre retorna as portas
        for _, data in ipairs(ControlledDoors) do
            if data.Align then
                data.Align.Attachment1 = baseAttachment
            end
        end

        print("[SHNMAX] Ataque finalizado em:", player.Name, flingDetected and "Flingado" or "Sem Fling")
    end

    -- Clique (funciona no mobile)
    UserInputService.TouchTap:Connect(function(touchPositions, processed)
        if processed then return end
        local pos = touchPositions[1]
        local camera = Workspace.CurrentCamera
        local unitRay = camera:ScreenPointToRay(pos.X, pos.Y)
        local raycast = Workspace:Raycast(unitRay.Origin, unitRay.Direction * 1000)

        if raycast and raycast.Instance then
            local hit = raycast.Instance
            local player = Players:GetPlayerFromCharacter(hit:FindFirstAncestorOfClass("Model"))
            if player and player ~= LocalPlayer then
                FlingPlayer(player)
            end
        end
    end)
end)

Fun:NewLabel("Helicopter Section (Premium Only)")

Fun:NewToggle("Helicopter Spam", function(state)
    -- state (true/false) indica se está ativado
    if state then
        local Players = game:GetService("Players")
local Player = Players.LocalPlayer
local Character = Player.Character
local RootPart = Character.HumanoidRootPart
local Humanoid = Character: FindFirstChildOfClass("Humanoid")
local molestado1 = workspace.WorkspaceCom["001_HeliCloneButton"].Button
getgenv().Toggle = true
while getgenv().Toggle do
task.wait()
RootPart.CFrame = molestado1.CFrame
task.wait(0.1)
fireclickdetector(molestado1.ClickDetector)
task.wait(0.5)
local molestado2 = game:GetService("Workspace").WorkspaceCom["001_HeliStorage"]:FindFirstChild("PoliceStationHeli")
if molestado2 then
repeat
RootPart.CFrame = molestado2.PrimaryPart.CFrame + Vector3.new(0,math.random(-1,1),0)
task.wait()
until Humanoid.Sit
task.wait(.1)
Humanoid.Sit = false
task.wait()
repeat
RootPart.CFrame = molestado2.Passenger1.CFrame + Vector3.new(0,math.random(-1,1),0)
task.wait()
until Humanoid.Sit
task.wait(0.2)
RootPart.CFrame = CFrame.new(math.random(-20,20) , 4.549, math.random(-20,20))
task.wait(0.2)
Humanoid.Sit = false
molestado2.Name = "PoliceStationHeliCartolaHub"
end
end
    end
end)

Fun:NewLabel("Helico Settings")

Dropdown = Fun:NewDropdown("Design List", {"Police", "Rescue", "Rich", "Military", "Agency", "Sheriff", "State Trooper"}, function(value)
        Callback = function(value)
            designHelico = value
             end
        end)

Fun:NewButton("Change Design", function()
if designHelico == "Police" then
 args = {
    [1] = game.Players.LocalPlayer.Name,
    [2] = "PoliceMeshID"
}

game:GetService("ReplicatedStorage").RE:FindFirstChild("1Max1y"):FireServer(unpack(args))
elseif designHelico == "Rescue" then
 args = {
    [1] = game.Players.LocalPlayer.Name,
    [2] = "RescueMeshID"
}

game:GetService("ReplicatedStorage").RE:FindFirstChild("1Max1y"):FireServer(unpack(args))
elseif designHelico == "Rich" then
 args = {
    [1] = game.Players.LocalPlayer.Name,
    [2] = "TubeTVMeshID"
}

game:GetService("ReplicatedStorage").RE:FindFirstChild("1Max1y"):FireServer(unpack(args))
elseif designHelico == "Military" then
 args = {
    [1] = game.Players.LocalPlayer.Name,
    [2] = "MilitaryMeshID"
}

game:GetService("ReplicatedStorage").RE:FindFirstChild("1Max1y"):FireServer(unpack(args))
elseif designHelico == "Agency" then
 args = {
    [1] = game.Players.LocalPlayer.Name,
    [2] = "AgencyMeshID"
}

game:GetService("ReplicatedStorage").RE:FindFirstChild("1Max1y"):FireServer(unpack(args))
elseif designHelico == "Sheriff" then
 args = {
    [1] = game.Players.LocalPlayer.Name,
    [2] = "SheriffMeshID"
}

game:GetService("ReplicatedStorage").RE:FindFirstChild("1Max1y"):FireServer(unpack(args))
elseif designHelico == "State Trooper" then
 args = {
    [1] = game.Players.LocalPlayer.Name,
    [2] = "StateTrooperMeshID"
}

game:GetService("ReplicatedStorage").RE:FindFirstChild("1Max1y"):FireServer(unpack(args))
  end
end)

Fun:NewLabel("Horse Section")

Fun:NewButton("Tp All Horse", function()
local players = game:GetService("Players")

for _, player in pairs(players:GetPlayers()) do
     args = {
        [1] = player
    }

    game:GetService("ReplicatedStorage").RE:FindFirstChild("1Hors1eRemot1e"):FireServer(unpack(args))
end
  	end)

Fun:NewLabel("Modded Gun")
local function equipSniper()
    local player = game.Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local backpack = player.Backpack
    local sniperTool = character:FindFirstChild("Sniper") or backpack:FindFirstChild("Sniper")

    if not sniperTool then
         args = {
            [1] = "PickingTools",
            [2] = "Sniper"
        }
        game:GetService("ReplicatedStorage"):WaitForChild("RE"):WaitForChild("1Too1l"):InvokeServer(unpack(args))
        task.wait(0.1)
        character.Humanoid:EquipTool(backpack:WaitForChild("Sniper"))
    elseif backpack:FindFirstChild("Sniper") then
        character.Humanoid:EquipTool(backpack["Sniper"])
    end
end

local function playSound(soundId)
    equipSniper()

    local player = game.Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local sniperHandle = character:FindFirstChild("Sniper") and character.Sniper:FindFirstChild("Handle")

    if sniperHandle then
        local sound = Instance.new("Sound")
        sound.SoundId = "rbxassetid://" .. tostring(soundId)
        sound.Volume = 0.1
        sound.Looped = false
        sound.Parent = player:WaitForChild("PlayerGui")
        sound:Play()
        sound.Ended:Connect(function()
            sound:Destroy()
        end)

         args = {
            [1] = sniperHandle,
            [2] = soundId,
            [3] = 1
        }
        game:GetService("ReplicatedStorage"):WaitForChild("RE"):WaitForChild("1Gu1nSound1s"):FireServer(unpack(args))
    end
end

Fun:NewButton("Jumpscare Gun", function()
    playSound(85435253347146)
end)

Fun:NewButton("Sus Gun", function()
    playSound(6701126635)
end)
Fun:NewButton("amongus Gun", function()
    playSound(6651571134)
end)
Fun:NewButton("Troll Laugh", function()
    playSound(7816195044)
end)
Fun:NewButton("Scream Entidade666 Gun", function()
    playSound(9043346124)
end)
Fun:NewButton("Tubers93 Gun", function()
    playSound(103215672097028)
end)

Fun:NewLabel("Sounds Gun")
local soundIdFromTextBox = nil

local function equipSniper()
    local player = game.Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local backpack = player.Backpack
    local sniperTool = character:FindFirstChild("Sniper") or backpack:FindFirstChild("Sniper")

    if not sniperTool then
         args = {
            [1] = "PickingTools",
            [2] = "Sniper"
        }
        game:GetService("ReplicatedStorage"):WaitForChild("RE"):WaitForChild("1Too1l"):InvokeServer(unpack(args))
        task.wait(0.1)
        character.Humanoid:EquipTool(backpack:WaitForChild("Sniper"))
    elseif backpack:FindFirstChild("Sniper") then
        character.Humanoid:EquipTool(backpack["Sniper"])
    end
end

local function playSound(soundId)
    equipSniper()

    local player = game.Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local sniperHandle = character:FindFirstChild("Sniper") and character.Sniper:FindFirstChild("Handle")

    if sniperHandle then
        local sound = Instance.new("Sound")
        sound.SoundId = "rbxassetid://" .. tostring(soundId)
        sound.Volume = 0.1
        sound.Looped = false
        sound.Parent = player:WaitForChild("PlayerGui")
        sound:Play()
        sound.Ended:Connect(function()
            sound:Destroy()
        end)

         args = {
            [1] = sniperHandle,
            [2] = tonumber(soundId),
            [3] = 1
        }
        game:GetService("ReplicatedStorage"):WaitForChild("RE"):WaitForChild("1Gu1nSound1s"):FireServer(unpack(args))
    end
end

Fun:NewTextBox("Sounds Box", "Enter Id here...", function(text)
    local num = tonumber(text)
    if num then
        soundIdFromTextBox = num
    end
end)

Fun:NewButton("Validate", function()
    if soundIdFromTextBox then
        playSound(soundIdFromTextBox)
    end
end)

Fun:NewLabel("Chat Troll Section")

Fun:NewButton("Press! Troll Error FilterChatMessage.Reconnecting..", function()
if game:GetService("TextChatService").ChatVersion == Enum.ChatVersion.TextChatService then game:GetService("TextChatService").TextChannels.RBXGeneral:SendAsync("hi\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\[Server]:Error FilterChatMessage.Reconnecting") else game:GetService("StarterGui"):SetCore("SendNotification", {Title = "Not Supported", Text = "This game has the legacy ROBLOX chat version. The script can only be used in the new version of the ROBLOX chat. Sorry :("}) end
    end)
    
Itens:NewLabel("Section Dupe Tools")

-- Dropdown for Item Selection
local ItemDropdown = Itens:NewDropdown("Select Item to Duplicate", {
    "Couch", "Crystal", "Crystals", "DSLR Camera", "SoccerBall", "EggLauncher",
    "Cuffs", "FireHose", "AgencyBook", "KeyCardWhite", "DuffleBagDiamonds",
    "BankGateKey", "SwordGold", "OldKey", "PaintRoller"
}, function(selectedItem)
    tool = selectedItem
end)

-- Dropdown for Quantity (simulating textbox)
Itens:NewDropdown("Number of Copies", {
    "1", "3", "5", "10", "15", "20", "30", "50", "100"
}, function(qtd)
    many = tonumber(qtd) or 0
end)

-- Remote References
local cleartoolremote = game:GetService("ReplicatedStorage").RE:FindFirstChild("1Clea1rTool1s")
local picktoolremote = game:GetService("ReplicatedStorage").RE:FindFirstChild("1Too1l")

-- General Control
local stopProcess = false
local duping = true

-- Reset Function
local function resetCharacter()
    local player = game.Players.LocalPlayer
    if player.Character then
        player.Character:BreakJoints()
    end
end

-- Duplication Function
Itens:NewButton("Start Duplication", function()
    if tool == "None" then return end

    local player = game.Players.LocalPlayer
    local char = player.Character
    local oldcf = char.HumanoidRootPart.CFrame

    if char.Humanoid.Sit then
        char.Humanoid.Sit = false
        task.wait()
    end

    -- Teleport and Preparation
    local cam = workspace:FindFirstChild("Camera")
    if cam then cam:Destroy() end

    char.HumanoidRootPart.CFrame = CFrame.new(999999999, -495, 999999999)
    char.HumanoidRootPart.Anchored = true
    task.wait(0.5)

    -- Clear Tools
    for _, obj in pairs(char:GetChildren()) do
        if obj:IsA("Tool") and obj.Name ~= tool then
            obj.Parent = player.Backpack
        end
    end

    for _, t in pairs(player.Backpack:GetChildren()) do
        if t:IsA("Tool") and t.Name ~= tool then
            t:Destroy()
        end
    end

    for _, t in pairs(char:GetChildren()) do
        if t:IsA("Tool") and t.Name ~= tool then
            t:Destroy()
        end
    end

    -- Rename and Prepare Tool
    local function handleTool(t)
        for _, part in pairs(t:GetDescendants()) do
            if part.Name == "Handle" then
                part.Name = "H⁥a⁥n⁥d⁥l⁥e"
                t.Parent = player.Backpack
                t.Parent = char
                return true
            end
        end
        return false
    end

    -- Ensure Clean Original Tool
    for _, t in pairs(player.Backpack:GetChildren()) do
        if t:IsA("Tool") and t.Name == tool then
            handleTool(t)
            repeat task.wait() until not char:FindFirstChild(t.Name)
        end
    end

    -- Duplication Loop
    for i = 1, many do
        if not duping then break end

        local cam = workspace:FindFirstChild("Camera")
        if cam then cam:Destroy() end

        picktoolremote:InvokeServer("PickingTools", tool)
        local newTool = player.Backpack:WaitForChild(tool)
        newTool.Parent = char

        task.wait()
        if newTool:FindFirstChild("Handle") then
            newTool.Handle.Name = "H⁥a⁥n⁥d⁥l⁥e"
        end

        newTool.Parent = player.Backpack
        newTool.Parent = char

        repeat
            local cam = workspace:FindFirstChild("Camera")
            if cam then cam:Destroy() end
            task.wait()
        until not char:FindFirstChild(tool)

        -- Notification
        game.StarterGui:SetCore("SendNotification", {
            Title = "Duplication",
            Text = "Duplicated [" .. tool .. "] (" .. i .. "/" .. many .. ")",
            Duration = 2,
            Icon = "rbxthumb://type=Asset&id=122216401159246&w=150&h=150"
        })
    end

    -- Final Reset
    char.HumanoidRootPart.Anchored = false
    repeat wait() until not char:FindFirstChild("HumanoidRootPart")
    repeat wait() until char:FindFirstChild("HumanoidRootPart")
    char.HumanoidRootPart.CFrame = oldcf
end)

-- Stop Button
Itens:NewButton("Stop Duplication", function()
    duping = false
end)

local BNumber = 2000

Itens:NewToggle("Spam Basketball", function(state)
    if state then
        local Player = game.Players.LocalPlayer
        local Backpack = Player and Player:FindFirstChild("Backpack")
        local Mouse = Player and Player:GetMouse()
        local Character = Player and Player.Character
        local Humanoid = Character and Character:FindFirstChildOfClass("Humanoid")
        local RootPart = Character and Character:FindFirstChild("HumanoidRootPart")
        local Clone = workspace:FindFirstChild("WorkspaceCom") and workspace.WorkspaceCom:FindFirstChild("001_GiveTools") and workspace.WorkspaceCom["001_GiveTools"]:FindFirstChild("Basketball")

        -- Verificações
        if not (Player and Backpack and Mouse and Character and Humanoid and RootPart and Clone) then
            warn("Erro: alguma instância necessária não foi encontrada.")
            return
        end

        local OldPos = RootPart.CFrame

        -- Spawn de bolas
        for i = 1, BNumber do
            task.wait()
            RootPart.CFrame = Clone.CFrame
            fireclickdetector(Clone:FindFirstChildOfClass("ClickDetector"))
        end

        task.wait()
        RootPart.CFrame = OldPos

        -- Loop de arremesso
        spawn(function()
            while state do
                task.wait()
                for _, tool in ipairs(Character:GetChildren()) do
                    if tool.Name == "Basketball" then
                        task.wait(0.0003)
                         args = {
                            Mouse.Hit.p
                        }
                        tool:FindFirstChild("ClickEvent"):FireServer(unpack(args))
                    end
                end
            end
        end)
    end
end)    

Others:NewLabel("Food Section")

Others:NewButton("Get Shopping Cart", function()
           args = {
          [1] = "PickingTools",
          [2] = "ShoppingCart"
          }
                        
picktoolremote:InvokeServer(unpack(args))
wait()
local character = player.Character
        local backpack = player.Backpack
        local humanoid = character:WaitForChild("Humanoid")
        local ShoppingCart = backpack:FindFirstChild("ShoppingCart")
        
        if not character:FindFirstChildOfClass("Tool") then
            if ShoppingCart then
                ShoppingCart.Parent = character
                humanoid:EquipTool(ShoppingCart)
             end
         end
    end)

local ChangeFoodCartloopEnabled = false
 
local function changeFoodLoop()
    while ChangeFoodCartloopEnabled do
     args = {
    [1] = "Banana"
}

game:GetService("Players").LocalPlayer.Character.ShoppingCart.ToolFood:FireServer(unpack(args))
wait(0.2)
     args = {
    [1] = "Coke"
}

game:GetService("Players").LocalPlayer.Character.ShoppingCart.ToolFood:FireServer(unpack(args))
wait(0.2)
 args = {
    [1] = "Bloxaide"
}

game:GetService("Players").LocalPlayer.Character.ShoppingCart.ToolFood:FireServer(unpack(args))
wait(0.2)
 args = {
    [1] = "BottledWater"
}

game:GetService("Players").LocalPlayer.Character.ShoppingCart.ToolFood:FireServer(unpack(args))
wait(0.2)
 args = {
    [1] = "GreenApple"
}

game:GetService("Players").LocalPlayer.Character.ShoppingCart.ToolFood:FireServer(unpack(args))
wait(0.2)
 args = {
    [1] = "Apple"
}

game:GetService("Players").LocalPlayer.Character.ShoppingCart.ToolFood:FireServer(unpack(args))
wait(0.2)
 args = {
    [1] = "Pizza"
}

game:GetService("Players").LocalPlayer.Character.ShoppingCart.ToolFood:FireServer(unpack(args))
wait(0.2)
 args = {
    [1] = "ChipsBlue"
}

game:GetService("Players").LocalPlayer.Character.ShoppingCart.ToolFood:FireServer(unpack(args))
wait(0.2)
 args = {
    [1] = "Chips"
}

game:GetService("Players").LocalPlayer.Character.ShoppingCart.ToolFood:FireServer(unpack(args))
wait(0.2)
 args = {
    [1] = "Milk"
}

game:GetService("Players").LocalPlayer.Character.ShoppingCart.ToolFood:FireServer(unpack(args))
      end
 end

Others:NewToggle("Loop Food", function(Value)
        if Value then
               ChangeFoodCartloopEnabled = true
            changeFoodLoop()
        else
           ChangeFoodCartloopEnabled = false
        end
    end)
    
Others:NewLabel("Trail Section")
Others:NewButton("Enable Trail", function()
    local character = player.Character
    if not character then return end

    local humanoid = character:FindFirstChildOfClass("Humanoid")
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not humanoid or not hrp then return end

    local oldPos = hrp.CFrame
    local firstPos = CFrame.new(-349, 5, 98)

    local poolClick = Workspace:FindFirstChild("WorkspaceCom"):FindFirstChild("001_Hospital"):FindFirstChild("PoolClick")
    if poolClick and poolClick:FindFirstChild("ClickDetector") then
        humanoid.WalkSpeed = 0
        humanoid.JumpPower = 0

        hrp.CFrame = firstPos
        task.wait(1)
        hrp.CFrame = poolClick.CFrame
        fireclickdetector(poolClick.ClickDetector)
        task.wait(0.7)
        hrp.CFrame = oldPos

        humanoid.WalkSpeed = 16
        humanoid.JumpPower = 50

        notify("Trail", "Trail obtido com sucesso!")
    else
        warn("PoolClick ou ClickDetector não encontrado!")
        notify("Erro", "Trail não encontrado.")
    end
end)

Others:NewButton("Disable Trail", function()
	local character = game.Players.LocalPlayer.Character
	local humanoid = character:FindFirstChild("Humanoid")

	for _, part in pairs(character:GetChildren()) do
		if part:IsA("Part") or part:IsA("BasePart") or part:IsA("MeshPart") then
			if part.Anchored then
				part.Anchored = false
			end
		end
	end

	if humanoid then
		humanoid.Health = 0
	end
end)

Others:NewLabel("Sitting Section")

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local player = Players.LocalPlayer

-- Conexões separadas por sistema
local antiToolSitConns = {}
local antiCarSitConns = {}

-- Função base de criação de AntiSit
local function createAntiSit(conns)
    local function preventSitting(humanoid)
        if humanoid then
            humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
            local conn = humanoid.StateChanged:Connect(function(_, new)
                if new == Enum.HumanoidStateType.Seated then
                    humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
                end
            end)
            table.insert(conns, conn)
        end
    end

    local function onCharacterAdded(character)
        local hum = character:WaitForChild("Humanoid")
        preventSitting(hum)
    end

    local charConn = player.CharacterAdded:Connect(onCharacterAdded)
    table.insert(conns, charConn)

    if player.Character then
        onCharacterAdded(player.Character)
    end

    local heartbeatConn = RunService.Heartbeat:Connect(function()
        local hum = player.Character and player.Character:FindFirstChildOfClass("Humanoid")
        if hum then
            hum:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
        end
    end)
    table.insert(conns, heartbeatConn)
end

-- Função base para resetar AntiSit
local function resetSit(conns)
    for _, conn in ipairs(conns) do
        conn:Disconnect()
    end
    table.clear(conns)

    local hum = player.Character and player.Character:FindFirstChildOfClass("Humanoid")
    if hum then
        hum:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
    end
end

-- Toggle 1: Anti Tool Sit
Others:NewToggle("Anti Tool Sit", function(state)
    if state then
        createAntiSit(antiToolSitConns)
    else
        resetSit(antiToolSitConns)
    end
end)

-- Toggle 2: Anti Car Sit
Others:NewToggle("Anti Car Sit", function(state)
    if state then
        createAntiSit(antiCarSitConns)
    else
        resetSit(antiCarSitConns)
    end
end)

Others:NewLabel("Tools")
Others:NewButton("Hold All Tools", function()
for _, tool in pairs(game:GetService("Players").LocalPlayer.Backpack:GetChildren()) do
    if tool:IsA("Tool") then
        tool.Parent = game.Players.LocalPlayer.Character
    end
  end
end)

Others:NewLabel("Airport")

Others:NewButton("Gun Detect", function()
    local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local Player = Players.LocalPlayer
    local Character = Player.Character or Player.CharacterAdded:Wait()
    local RootPart = Character:WaitForChild("HumanoidRootPart")
    local OldPos = RootPart.CFrame

    local ToolRemote = ReplicatedStorage:FindFirstChild("RE"):FindFirstChild("1Too1l")
    local ClearRemote = ReplicatedStorage:FindFirstChild("RE"):FindFirstChild("1Clea1rTool1s")

    if ToolRemote and ClearRemote then
        local success, err = pcall(function()
            ToolRemote:InvokeServer("PickingTools", "Sniper")
            local Sniper = Player.Backpack:FindFirstChild("Sniper")
            if Sniper then
                Sniper.Parent = Character
            end

            task.wait(0.5)
            RootPart.CFrame = CFrame.new(332, 4, 73)
            task.wait(2)
            RootPart.CFrame = OldPos
            task.wait(0.1)

            ClearRemote:FireServer("PlayerWantsToDeleteTool", "Sniper")
        end)

        if not success then
            warn("Gun Detect Failed: ", err)
        end
    else
        warn("Required remotes not found in ReplicatedStorage.RE")
    end
end)

Others:NewLabel("Chat Section (Roblox ban risk)")

local TextSave
local tcs = game:GetService("TextChatService")
local chat = tcs.ChatInputBarConfiguration.TargetTextChannel

function sendchat(msg)
	if tcs.ChatVersion == Enum.ChatVersion.LegacyChatService then
		game:GetService("ReplicatedStorage"):FindFirstChild("DefaultChatSystemChatEvents").SayMessageRequest:FireServer(msg, "All")
	else
		chat:SendAsync(msg)
	end
end

Others:NewTextBox("Chat Box", "Enter text here...", function(text)
		TextSave = text
	end)

Others:NewButton("Validate", function()
		sendchat(TextSave)
	end)

local spamDelay = 1.2

Others:NewToggle("Loop Chat", function(Value)
		getgenv().ShnmaxSpawnText = Value
		while getgenv().ShnmaxSpawnText do
			sendchat(TextSave)
			task.wait(spamDelay)
		end
	end)

Others:NewLabel("Commercial Section")
Others:NewTextBox("Commercial 1", "Enter text here...", function(value)
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:wait(0.1)
local initialPosition = character.HumanoidRootPart.Position

local destination = Vector3.new(444.73675537109375, 63.137306213378906, 512.9107055664062)

character.HumanoidRootPart.CFrame = CFrame.new(destination)
         args = {
            [1] = "ReturningCommercialWords",
            [2] = 1,
            [4] = value
        }
        game:GetService("ReplicatedStorage").RE["1Cemeter1y"]:FireServer(unpack(args))

         args = {
            [1] = "CommercialBackGround",
            [2] = 1,
            [3] = Color3.new(0, 0, 0)
        }
        game:GetService("ReplicatedStorage").RE["1Cemeter1y"]:FireServer(unpack(args))

         args = {
            [1] = "CommercialWordColor",
            [2] = 1,
            [3] = Color3.new(1, 0, 0.0461044)
        }
        game:GetService("ReplicatedStorage").RE["1Cemeter1y"]:FireServer(unpack(args))
wait(0.7)
character.HumanoidRootPart.CFrame = CFrame.new(initialPosition)
    end)

Others:NewTextBox("Commercial 2", "Enter text here...", function(value)
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:wait(0.1)
local initialPosition = character.HumanoidRootPart.Position

local destination = Vector3.new(-634.5044555664062, 25.402376174926758, 362.7777404785156)

character.HumanoidRootPart.CFrame = CFrame.new(destination)
         args = {
            [1] = "ReturningCommercialWords",
            [2] = 2,
            [4] = value
        }
        game:GetService("ReplicatedStorage").RE["1Cemeter1y"]:FireServer(unpack(args))

         args = {
            [1] = "CommercialBackGround",
            [2] = 2,
            [3] = Color3.new(0, 0, 0)
        }
        game:GetService("ReplicatedStorage").RE["1Cemeter1y"]:FireServer(unpack(args))

         args = {
            [1] = "CommercialWordColor",
            [2] = 2,
            [3] = Color3.new(1, 0, 0.0461044)
        }
        game:GetService("ReplicatedStorage").RE["1Cemeter1y"]:FireServer(unpack(args))
wait(0.7)
character.HumanoidRootPart.CFrame = CFrame.new(initialPosition)
    end)

Others:NewTextBox("Commercial 3", "Enter text here...", function(value)
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:wait(0.1)
local initialPosition = character.HumanoidRootPart.Position

local destination = Vector3.new(-238.48960876464844, 88.5223617553711, -549.606689453125)

character.HumanoidRootPart.CFrame = CFrame.new(destination)
         args = {
            [1] = "ReturningCommercialWords",
            [2] = 3,
            [4] = value
        }
        game:GetService("ReplicatedStorage").RE["1Cemeter1y"]:FireServer(unpack(args))

         args = {
            [1] = "CommercialBackGround",
            [2] = 3,
            [3] = Color3.new(0, 0, 0)
        }
        game:GetService("ReplicatedStorage").RE["1Cemeter1y"]:FireServer(unpack(args))

         args = {
            [1] = "CommercialWordColor",
            [2] = 3,
            [3] = Color3.new(1, 0, 0.0461044)
        }
        game:GetService("ReplicatedStorage").RE["1Cemeter1y"]:FireServer(unpack(args))
wait(0.7)
character.HumanoidRootPart.CFrame = CFrame.new(initialPosition)
    end)
    
Teleportes:NewLabel("Teleports")

local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local StarterGui = game:GetService("StarterGui")
local player = Players.LocalPlayer

local function safeCall(func)
    local success, err = pcall(func)
    if not success then
        warn("Erro detectado: " .. err)
    end
end

local function notify(title, text)
    StarterGui:SetCore("SendNotification", {
        Title = title,
        Text = text,
        Icon = "rbxthumb://type=Asset&id=122216401159246&w=150&h=150",
        Duration = 3
    })
end

local function teleportWithTween(targetPosition, nomeLocal)
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

    if targetPosition and humanoidRootPart then
        local goal = {CFrame = CFrame.new(targetPosition)}
        local tweenInfo = TweenInfo.new(1, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
        local tween = TweenService:Create(humanoidRootPart, tweenInfo, goal)
        tween:Play()

        tween.Completed:Connect(function()
            notify("Teleporte concluído", "Você foi para " .. nomeLocal)
        end)
    else
        warn("Posição ou personagem inválido para teleporte!")
    end
end

local teleportes = {
    {"Start", Vector3.new(-26.786, 4.549, -16.025)},
    {"Burger Barn", Vector3.new(149.82, 5.549, 60.242)},
    {"Motel", Vector3.new(170.196, 5.549, 266.061)},
    {"Police Station", Vector3.new(-119.9, 4.641, 8.176)},
    {"Ice Cream Shop", Vector3.new(-130.075, 4.649, -127.652)},
    {"Arcade", Vector3.new(-168.064, 4.649, -112.339)},
    {"Hair Salon", Vector3.new(-72.252, 4.649, -122.569)},
    {"Supermarket", Vector3.new(10.353, 4.649, -115.098)},
    {"Mall", Vector3.new(153.754, 4.775, -146.444)},
    {"Cinema", Vector3.new(198.996, -33.061, -179.751)},
    {"Airport", Vector3.new(295.139, 5.549, 40.569)},
    {"Bank", Vector3.new(1.074, 4.549, 237.577)},
    {"Clothing Store", Vector3.new(-41.549, 4.549, 238.717)},
    {"Cafe", Vector3.new(-96.891, 4.549, 236.663)},
    {"Library", Vector3.new(-129.832, 4.549, 242.131)},
    {"Post Office", Vector3.new(-183.435, 4.549, 240.83)},
    {"School", Vector3.new(-301.655, 4.749, 212.338)},
    {"Hospital", Vector3.new(-304.652, 4.636, 14.17)},
    {"Town Hall", Vector3.new(-354.4, 8.555, -101.754)},
    {"Fire Department", Vector3.new(-430.852, 4.549, -103.408)},
    {"Farm Horses", Vector3.new(-765.745, 4.149, -60.722)},
    {"Farm", Vector3.new(-842.876, 4.149, -395.368)},
    {"Drone Mountain", Vector3.new(-661.048, 251.373, 753.847)},
    {"Beach", Vector3.new(-236.487, 1.136, 760.252)},
    {"Forest House", Vector3.new(-186.256, 4.149, 1067.567)},
}

-- Substituir AddButton por NewButton
for _, info in ipairs(teleportes) do
    local nome, pos = info[1], info[2]
    Teleportes:NewButton("Teleporte " .. nome, function()
        safeCall(function()
            teleportWithTween(pos, nome)
        end)
    end)
end    
    
Misc:NewLabel("Section Misc")

Misc:NewButton("Ant Lag All", function()
    local itemsToRemove = { "Laptop", "Bomb", "Phone", "FireEx", "FireHose", "Basketball" }
    local removeLookup = {}
    
    -- Adiciona os itens que devem ser removidos no dicionário
    for _, name in ipairs(itemsToRemove) do
        removeLookup[name] = true
    end

    local ClearDelay = 0.5 -- Delay entre cada varredura (ajustável)

    -- Função para destruir os itens do personagem
    local function destroyItemsInCharacter(character)
        if not character then return end
        for _, item in ipairs(character:GetChildren()) do
            if removeLookup[item.Name] then
                pcall(function()
                    item:Destroy()
                end)
            end
        end
    end

    -- Função para processar os jogadores
    local function processPlayers()
        for _, player in ipairs(game.Players:GetPlayers()) do
            pcall(function()
                if player.Character then
                    destroyItemsInCharacter(player.Character)
                end
            end)
        end
    end

    -- Spawn a task para rodar a função continuamente
    task.spawn(function()
        while task.wait(ClearDelay) do
            processPlayers()
        end
    end)
end)

Misc:NewLabel("Section Audio All FE")

-- Inicialização das variáveis
local ReplicatedStorage = game:GetService("ReplicatedStorage")

if not _G.audio_all_delay then
    _G.audio_all_delay = 1
end

local function Audio_All_ClientSide(ID)
    local function CheckFolderAudioAll()
        local FolderAudio = workspace:FindFirstChild("Audio all client")
        if not FolderAudio then
            FolderAudio = Instance.new("Folder")
            FolderAudio.Name = "Audio all client"
            FolderAudio.Parent = workspace
        end
        return FolderAudio
    end

    local function CreateSound(ID)
        if type(ID) ~= "number" then
            print("Insira um número válido!")
            return nil
        end

        local Folder_Audio = CheckFolderAudioAll()
        if Folder_Audio then
            local Sound = Instance.new("Sound")
            Sound.SoundId = "rbxassetid://" .. ID
            Sound.Volume = 1
            Sound.Looped = false
            Sound.Parent = Folder_Audio
            Sound:Play()
            task.wait(1) -- Tempo de espera antes de remover o som
            Sound:Destroy()
        end
    end

    CreateSound(ID)
end

local function Audio_All_ServerSide(ID)
    if type(ID) ~= "number" then
        print("Insira um número válido!")
        return nil
    end

    local GunSoundEvent = ReplicatedStorage:FindFirstChild("1Gu1nSound1s", true)
    if GunSoundEvent then
        GunSoundEvent:FireServer(workspace, ID, 1)
    end
end

-- Lista de sons irritantes
local soundList = {
    {Name = "Grito Alto", ID = 5710016194},
    {Name = "Jumpscare Horroroso", ID = 85435253347146},
    {Name = "Áudio Alto", ID = 6855150757},
    {Name = "Ruído", ID = 120034877160791},
    {Name = "Jumpscare 2", ID = 110637995610528},
    {Name = "Risada Da Bruxa Minecraft", ID = 116214940486087},
    {Name = "The Boiled One", ID = 137177653817621},
    {Name = "Deitei Um Ave Maria Doido", ID = 128669424001766},
    {Name = "Mandrake Detected", ID = 9068077052},
    {Name = "Aaaaaaaaa", ID = 80156405968805},
    {Name = "AAAHHHH", ID = 9084006093},
    {Name = "amongus", ID = 6651571134},
    {Name = "Sus", ID = 6701126635},
    {Name = "Gritao AAAAAAAAA", ID = 5853668794},
    {Name = "UHHHHH COFFCOFF", ID = 7056720271},
    {Name = "SUS", ID = 7153419575},
    {Name = "Scary Laugh", ID = 7854285068},
    {Name = "Zombie Laugh", ID = 4810729995},
    {Name = "Troll Laugh", ID = 7816195044},
    {Name = "Sonic Exe Laugh", ID = 18379039436},
    {Name = "Boss Laugh", ID = 124736244667477},
    {Name = "Nuclear Alarm", ID = 675587093},
    {Name = "Nuclear Alarm 2", ID = 6466025566},
    {Name = "Tubers93", ID = 103215672097028},
    {Name = "Nossa", ID = 76827197751073},
    {Name = "Sai Do Meio Satanás", ID = 127944706557246},
    {Name = "Woop Woop Policie", ID = 93038115551055},
    {Name = "F", ID = 6832470734},
    {Name = "ZAP ZAP", ID = 17517499979},
    {Name = "Olha a mensagem", ID = 17780313297},
    {Name = "Scream Entidade666", ID = 9043346124},
}

-- Variáveis de controle
local options = {}
local audio_all_dropdown_value = nil

for _, sound in ipairs(soundList) do
    table.insert(options, sound.Name)
end

-- Função para tocar áudio
local function playAudio(audioId)
    if not audioId then
        warn("[Áudio ALL] Nenhum ID de áudio selecionado.")
        return
    end
    Audio_All_ServerSide(audioId)
    task.spawn(function()
        Audio_All_ClientSide(audioId)
    end)
end

-- Atualização de Dropdown
Misc:NewDropdown("Áudio ALL - Dropdown", options, function(selectedName)
    for _, sound in ipairs(soundList) do
        if sound.Name == selectedName then
            audio_all_dropdown_value = sound.ID
            break
        end
    end
    if not audio_all_dropdown_value then
        warn("[Áudio ALL] Nome selecionado inválido: " .. tostring(selectedName))
    end
end)

-- Novo botão para áudio
Misc:NewButton("Áudio ALL - OnlyKick", function()
    if audio_all_dropdown_value then
        playAudio(audio_all_dropdown_value)
    else
        warn("[Áudio ALL] Nenhum áudio selecionado para tocar.")
    end
end)

-- Novo Toggle para loop de áudio
Misc:NewToggle("Áudio ALL - OnlyKick (All Client) Loop", function(state)
    getgenv().Audio_All_loop = state

    if state then
        warn("[Áudio ALL] Loop iniciado. Boa sorte, ouvidos.")
        task.spawn(function()
            while getgenv().Audio_All_loop do
                if audio_all_dropdown_value then
                    playAudio(audio_all_dropdown_value)
                else
                    warn("[Áudio ALL] Nenhum áudio válido no loop.")
                end
                task.wait(_G.audio_all_delay or 2)
            end
            warn("[Áudio ALL] Loop encerrado. Silêncio restaurado.")
        end)
    else
        warn("[Áudio ALL] Loop desligado.")
    end
end)

-- Toggle para Audio Spam Fast Glitcher
local audioID = 103215672097028 -- ID fixo do áudio
Misc:NewToggle("Áudio Spam Fast Glitcher", function(state)
    getgenv().Audio_All_loop_fast = state

    while getgenv().Audio_All_loop_fast do
        Audio_All_ServerSide(audioID)
        task.spawn(function()
            Audio_All_ClientSide(audioID)
        end)
        task.wait(0.00003)
    end
end)

Misc:NewLabel("Section Boombox FE")

Misc:NewButton("Boombox 100% FE", function()
    local player = game.Players.LocalPlayer
    local playerGui = player:FindFirstChild("PlayerGui")
    if not playerGui then return end

    local boombox
    local sg
    local lastID = 142376088

    local function createBoombox()
        boombox = Instance.new("Tool")
        boombox.Name = "Boombox"
        boombox.RequiresHandle = true
        boombox.Parent = player.Backpack

        local handle = Instance.new("Part")
        handle.Name = "Handle"
        handle.Size = Vector3.new(1, 1, 1)
        handle.CanCollide = false
        handle.Anchored = false
        handle.Transparency = 1
        handle.Parent = boombox

        boombox.Equipped:Connect(function()
            if sg then return end

            sg = Instance.new("ScreenGui")
            sg.Name = "ChooseSongGui"
            sg.Parent = playerGui  

            local frame = Instance.new("Frame")
            frame.Style = "RobloxRound"
            frame.Size = UDim2.new(0.25, 0, 0.25, 0)
            frame.Position = UDim2.new(0.375, 0, 0.375, 0)
            frame.Draggable = true
            frame.Active = true
            frame.Parent = sg

            local text = Instance.new("TextLabel")
            text.BackgroundTransparency = 1
            text.TextStrokeTransparency = 0
            text.TextColor3 = Color3.new(1, 1, 1)
            text.Size = UDim2.new(1, 0, 0.6, 0)
            text.TextScaled = true
            text.Text = "Lay down the beat! Put in the ID number for a song you love that's been uploaded to ROBLOX. Leave it blank to stop playing music."
            text.Parent = frame

            local input = Instance.new("TextBox")
            input.BackgroundColor3 = Color3.new(0, 0, 0)
            input.BackgroundTransparency = 0.5
            input.BorderColor3 = Color3.new(1, 1, 1)
            input.TextColor3 = Color3.new(1, 1, 1)
            input.TextStrokeTransparency = 1
            input.TextScaled = true
            input.Text = tostring(lastID)
            input.Size = UDim2.new(1, 0, 0.2, 0)
            input.Position = UDim2.new(0, 0, 0.6, 0)
            input.Parent = frame

            local button = Instance.new("TextButton")
            button.Style = "RobloxButton"
            button.Size = UDim2.new(0.75, 0, 0.2, 0)
            button.Position = UDim2.new(0.125, 0, 0.8, 0)
            button.TextColor3 = Color3.new(1, 1, 1)
            button.TextStrokeTransparency = 0
            button.Text = "Play!"
            button.TextScaled = true
            button.Parent = frame

             args = {
                [1] = 18756289999
            }
            game:GetService("ReplicatedStorage").Remotes.Wear:InvokeServer(unpack(args))

            local function playAudioAll(ID)
                if type(ID) ~= "number" then
                    print("Please insert a valid number!")
                    return
                end
                local rs = game:GetService("ReplicatedStorage")
                local evt = rs:FindFirstChild("1Gu1nSound1s", true)
                if evt then
                    evt:FireServer(workspace, ID, 1)
                end
            end

            local function playAudioLocal(ID)
                local sound = Instance.new("Sound")
                sound.SoundId = "rbxassetid://" .. ID
                sound.Volume = 1
                sound.Looped = false
                sound.Parent = player.Character or workspace
                sound:Play()
                task.wait(3)
                sound:Destroy()
            end

            button.MouseButton1Click:Connect(function()
                local soundID = tonumber(input.Text)
                if soundID then
                    lastID = soundID
                    playAudioAll(soundID)
                    playAudioLocal(soundID)
                    if sg then
                        sg:Destroy()
                        sg = nil
                    end
                else
                    print("Invalid ID!")
                end
            end)
        end)

        boombox.Unequipped:Connect(function()
            if sg then
                sg:Destroy()
                sg = nil
            end
             args = {
                [1] = 18756289999
            }
            game:GetService("ReplicatedStorage").Remotes.Wear:InvokeServer(unpack(args))
        end)

        boombox.AncestryChanged:Connect(function(_, parent)
            if not parent and sg then
                sg:Destroy()
                sg = nil
            end
        end)
    end

    createBoombox()
end)

local StarterGui = game:GetService("StarterGui")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

-- Função para notificação padrão Roblox
local function notify(title, text, duration)
    StarterGui:SetCore("SendNotification", {
        Title = title,
        Text = text,
        Duration = duration or 3
    })
end

-- Função para obter o Humanoid
local function getHumanoid()
    character = player.Character or player.CharacterAdded:Wait()
    return character:FindFirstChildOfClass("Humanoid")
end

-- Serviços
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local StarterGui = game:GetService("StarterGui")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

-- Player local
local player = Players.LocalPlayer

-- Notificação padrão
local function notify(title, text, duration)
    StarterGui:SetCore("SendNotification", {
        Title = title,
        Text = text,
        Duration = duration or 3
    })
end

-- INFINITE JUMP
local InfiniteJumpAtivado = false

local function toggleInfiniteJump(ativo)
    InfiniteJumpAtivado = ativo
    notify("Infinite Jump", ativo and "Ativado" or "Desativado")
end

UserInputService.JumpRequest:Connect(function()
    if InfiniteJumpAtivado then
        local humanoid = player.Character and player.Character:FindFirstChildWhichIsA("Humanoid")
        if humanoid then
            humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        end
    end
end)

Misc:NewToggle("Infinite Jump", function(state)
    toggleInfiniteJump(state)
end)

-- NOCLIP
local NoclipAtivado = false
local NoclipConnection

local function toggleNoclip(ativo)
    NoclipAtivado = ativo
    notify("Noclip", ativo and "Ativado" or "Desativado")

    if NoclipConnection then
        NoclipConnection:Disconnect()
        NoclipConnection = nil
    end

    if ativo then
        NoclipConnection = RunService.Stepped:Connect(function()
            local char = player.Character
            if char then
                for _, part in pairs(char:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = false
                    end
                end
            end
        end)
    end
end

Misc:NewToggle("Noclip", function(state)
    toggleNoclip(state)
end)    

Kill:NewLabel("Section Kill View")

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local StarterGui = game:GetService("StarterGui")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local CurrentCamera = workspace.CurrentCamera

local viewEnabled = false
local currentTarget = nil
local characterAddedConn = nil
local lastValidTarget = nil

local notificationIconId = "rbxassetid://122216401159246"

-- Notificação com headshot
function notify(title, text, player)
    local icon = notificationIconId

    if player and Players:FindFirstChild(player.Name) then
        local success, thumb = pcall(function()
            return Players:GetUserThumbnailAsync(
                player.UserId,
                Enum.ThumbnailType.HeadShot,
                Enum.ThumbnailSize.Size150x150
            )
        end)
        if success and thumb then
            icon = thumb
        end
    end

    StarterGui:SetCore("SendNotification", {
        Title = title,
        Text = text,
        Icon = icon,
        Duration = 4
    })
end

-- Buscar jogador
function findPlayerByName(partialName)
    if not partialName or partialName == "" then return nil end

    partialName = partialName:lower()
    local foundPlayers = {}

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            local nameMatch = player.Name:lower():find(partialName, 1, true)
            local displayNameMatch = player.DisplayName:lower():find(partialName, 1, true)

            if nameMatch or displayNameMatch then
                table.insert(foundPlayers, {
                    player = player,
                    priority = (player.Name:lower():sub(1, #partialName) == partialName or player.DisplayName:lower():sub(1, #partialName) == partialName) and 1 or 2
                })
            end
        end
    end

    table.sort(foundPlayers, function(a, b)
        if a.priority ~= b.priority then
            return a.priority < b.priority
        end
        return #a.player.Name < #b.player.Name
    end)

    return foundPlayers[1] and foundPlayers[1].player or nil
end

-- Resetar câmera
function resetCamera()
    if LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait() then
        CurrentCamera.CameraSubject = LocalPlayer.Character:WaitForChild("Humanoid")
    end
end

-- Definir alvo
function setViewTarget(targetPlayer)
    if not targetPlayer or not targetPlayer:IsDescendantOf(Players) then
        notify("Erro", "Jogador inválido ou desconectado.")
        stopViewing()
        return
    end

    currentTarget = targetPlayer
    getgenv().Target = targetPlayer.Name
    lastValidTarget = targetPlayer.Name

    if characterAddedConn then
        characterAddedConn:Disconnect()
    end

    characterAddedConn = targetPlayer.CharacterAdded:Connect(function(char)
        task.wait(0.5)
        if viewEnabled and currentTarget == targetPlayer then
            local humanoid = char:WaitForChild("Humanoid", 5)
            if humanoid then
                CurrentCamera.CameraSubject = humanoid
            end
        end
    end)

    if targetPlayer.Character then
        local humanoid = targetPlayer.Character:FindFirstChild("Humanoid") or targetPlayer.Character:WaitForChild("Humanoid", 2)
        if humanoid then
            CurrentCamera.CameraSubject = humanoid
        end
    end
end

-- Parar visualização
function stopViewing()
    viewEnabled = false
    currentTarget = nil
    if characterAddedConn then
        characterAddedConn:Disconnect()
        characterAddedConn = nil
    end
    resetCamera()
    notify("View", "Visualização desativada.")
end

-- Render loop
RunService.RenderStepped:Connect(function()
    if viewEnabled and currentTarget then
        if not currentTarget:IsDescendantOf(game) then
            stopViewing()
            return
        end
        if currentTarget.Character then
            local humanoid = currentTarget.Character:FindFirstChildOfClass("Humanoid")
            if humanoid and CurrentCamera.CameraSubject ~= humanoid then
                pcall(function()
                    CurrentCamera.CameraSubject = humanoid
                end)
            end
        end
    end
end)

-- UI Elements
local PlayerTextBox = Kill:NewTextBox("Target Player", "name or nickname..", function(texto)
    if texto == "" then
        if lastValidTarget then
            texto = lastValidTarget
        else
            notify("Erro", "Você precisa digitar um nome.")
            return
        end
    end

    local targetPlayer = findPlayerByName(texto)

    if targetPlayer and targetPlayer:IsDescendantOf(Players) then
        getgenv().Target = targetPlayer.Name
        lastValidTarget = targetPlayer.Name
        currentTarget = targetPlayer

        notify("Jogador Selecionado", "Alvo: " .. targetPlayer.DisplayName .. " (" .. targetPlayer.Name .. ")", targetPlayer)

        if viewEnabled then
            setViewTarget(targetPlayer)
        end
    else
        getgenv().Target = nil
        lastValidTarget = nil
        currentTarget = nil
        stopViewing()
        notify("Erro", "Nenhum jogador encontrado com: " .. texto)
    end
end)

Kill:NewToggle("View", function(state)
    viewEnabled = state
    if state and getgenv().Target then
        local targetPlayer = findPlayerByName(getgenv().Target)
        if targetPlayer and targetPlayer:IsDescendantOf(Players) then
            setViewTarget(targetPlayer)
            notify("View Ativado", "Observando " .. targetPlayer.DisplayName .. " (" .. targetPlayer.Name .. ")", targetPlayer)
        else
            notify("Erro", "Jogador não encontrado: " .. tostring(getgenv().Target))
            viewEnabled = false
        end
    else
        stopViewing()
    end
end)

Kill:NewButton("Goto", function()
    local success, err = pcall(function()
        local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local hrp = character:FindFirstChild("HumanoidRootPart")

        if not hrp then 
            notify("Goto", "Seu personagem não tem HumanoidRootPart.")
            return 
        end

        local targetName = getgenv().Target
        if not targetName then
            notify("Goto", "Nenhum jogador selecionado.")
            return
        end

        local targetPlayer = findPlayerByName(targetName)
        if not targetPlayer or not targetPlayer.Character then
            notify("Goto", "Jogador inválido ou offline.")
            return
        end

        local targetHRP = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not targetHRP then
            notify("Goto", "Jogador sem HumanoidRootPart.")
            return
        end

        hrp.CFrame = targetHRP.CFrame + Vector3.new(0, 3, 0)
        notify("Teleportado", "Você foi até " .. targetPlayer.DisplayName .. " (" .. targetPlayer.Name .. ")", targetPlayer)
    end)

    if not success then
        warn("[GOTO] Erro ao teleportar:", err)
        notify("Erro", "Falha ao teleportar: " .. tostring(err))
    end
end)

-- Alvo inicial
if getgenv().Target then
    local targetPlayer = findPlayerByName(getgenv().Target)
    if targetPlayer and targetPlayer:IsDescendantOf(Players) then
        lastValidTarget = targetPlayer.Name
    else
        getgenv().Target = nil
    end
end

Kill:NewLabel("Troll")

Kill:NewButton("Fling Ball", function()
    local targetPlayer = game.Players:FindFirstChild(getgenv().Target)
    if not targetPlayer or not targetPlayer.Character then
        warn("Nenhum jogador selecionado.") 
        return 
    end

    -- Limpa a ferramenta
     argsClear = {
        [1] = "PlayerWantsToDeleteTool",
        [2] = "SoccerBall"
    }
    game:GetService("ReplicatedStorage").RE:FindFirstChild("1Clea1rTool1s"):FireServer(unpack(argsClear))

    -- Pega a bola
     argsTool = {
        [1] = "PickingTools",
        [2] = "SoccerBall"
    }
    game:GetService("ReplicatedStorage").RE:FindFirstChild("1Too1l"):InvokeServer(unpack(argsTool))

    -- Move a bola pro personagem
    local ball = game.Players.LocalPlayer.Backpack:FindFirstChild("SoccerBall")
    if not ball then
        warn("Bola não encontrada na mochila.")
        return
    end
    ball.Parent = game.Players.LocalPlayer.Character

    -- Espera carregar tudo
    wait(0.5)

    -- Loop até o alvo estar com 1 de vida
    repeat
        task.wait()

        local hrp = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not hrp then break end

        local pos = hrp.Position + hrp.Velocity / 10
        local randomOffset = math.random(-10, 10)

        local soccerBall = workspace.WorkspaceCom["001_SoccerBalls"]:FindFirstChild("Soccer" .. game.Players.LocalPlayer.Name)
        if not soccerBall then
            warn("Bola no workspace não encontrada.")
            break
        end

        soccerBall.CFrame = CFrame.new(pos) + Vector3.new(randomOffset, 0, 0)

        -- Adiciona força absurda
        local bodyForce = Instance.new("BodyForce")
        bodyForce.Force = Vector3.new(9e6, 9e6, 9e6)
        bodyForce.Parent = soccerBall

        local spin = Instance.new("BodyAngularVelocity")
        spin.AngularVelocity = Vector3.new(9e6, 9e6, 9e6)
        spin.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
        spin.P = 1250
        spin.Parent = soccerBall

    until targetPlayer.Character:FindFirstChild("Humanoid") and targetPlayer.Character.Humanoid.Health <= 1
end)

Kill:NewButton("Bring Couch", function()
    local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local Player = Players.LocalPlayer
    local Backpack = Player:WaitForChild("Backpack")
    local Character = Player.Character or Player.CharacterAdded:Wait()
    local Humanoid = Character:WaitForChild("Humanoid")
    local RootPart = Character:WaitForChild("HumanoidRootPart")

    -- Função para checar se já tem o Couch (equipado ou na backpack)
    local function HasCouch()
        return Backpack:FindFirstChild("Couch") or Character:FindFirstChild("Couch")
    end

    -- Equipar Couch, ajustar GripPos e só então equipar para usar
    local function EquipCouch()
        if HasCouch() then return true end

        local remote = ReplicatedStorage:FindFirstChild("RE") and ReplicatedStorage.RE:FindFirstChild("1Too1l")
        if not remote then
            warn("Remote para equipar Couch não encontrado.")
            return false
        end

        local args = { "PickingTools", "Couch" }
        remote:InvokeServer(unpack(args))

        local timeout = 5
        local startTime = tick()
        while not Backpack:FindFirstChild("Couch") and tick() - startTime < timeout do
            task.wait(0.1)
        end

        local couchTool = Backpack:FindFirstChild("Couch")
        if not couchTool then
            warn("Falha ao obter Couch na backpack.")
            return false
        end

        -- Ajusta GripPos para reposicionar o item
        if couchTool:FindFirstChild("Handle") then
            couchTool.GripPos = Vector3.new(2, 5, -1)
        else
            warn("Handle não encontrado no item Couch")
        end

        -- Agora equipa o Couch ajustado
        Humanoid:EquipTool(couchTool)
        return true
    end

    -- Equipa o Couch e só segue se conseguir
    if not EquipCouch() then
        return
    end

    -- Seleciona o alvo
    local TargetPlayer = Players:FindFirstChild(getgenv().Target)
    if not TargetPlayer or not TargetPlayer.Character then
        return warn("Alvo inválido ou personagem não encontrado.")
    end

    local TCharacter = TargetPlayer.Character
    local THumanoid = TCharacter:FindFirstChildOfClass("Humanoid")
    local TRootPart = THumanoid and THumanoid.RootPart
    local THead = TCharacter:FindFirstChild("Head")
    local Accessory = TCharacter:FindFirstChildOfClass("Accessory")
    local Handle = Accessory and Accessory:FindFirstChild("Handle")

    -- Salva posição original se o player estiver parado
    if RootPart.Velocity.Magnitude < 50 then
        getgenv().OldPos = RootPart.CFrame
    end

    -- Função que reposiciona o player em relação a uma base com offset e ângulo
    local function FPos(BasePart, Pos, Ang)
        RootPart.CFrame = CFrame.new(BasePart.Position) * Pos * Ang
        Character:SetPrimaryPartCFrame(CFrame.new(BasePart.Position) * Pos * Ang)
        RootPart.Velocity = Vector3.new(9e7, 9e7 * 10, 9e7)
        RootPart.RotVelocity = Vector3.new(9e8, 9e8, 9e8)
    end

    -- Movimento dinâmico para 'empurrar' o alvo
    local function SFBasePart(BasePart)
        local TimeToWait = 2
        local Time = tick()
        local Angle = 0

        repeat
            if RootPart and THumanoid then
                if BasePart.Velocity.Magnitude < 50 then
                    Angle += 100
                    FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle),0 ,0))
                    task.wait()

                    FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                    task.wait()

                    FPos(BasePart, CFrame.new(2.25, 1.5, -2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                    task.wait()

                    FPos(BasePart, CFrame.new(-2.25, -1.5, 2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                    task.wait()

                    FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection, CFrame.Angles(math.rad(Angle), 0, 0))
                    task.wait()

                    FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection, CFrame.Angles(math.rad(Angle), 0, 0))
                    task.wait()

                    FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
                    task.wait()

                    FPos(BasePart, CFrame.new(0, -1.5, -THumanoid.WalkSpeed), CFrame.Angles(0, 0, 0))
                    task.wait()

                    FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
                    task.wait()

                    FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(math.rad(90), 0, 0))
                    task.wait()

                    FPos(BasePart, CFrame.new(0, -1.5, -TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(0, 0, 0))
                    task.wait()

                    FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(math.rad(90), 0, 0))
                    task.wait()

                    FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(math.rad(90), 0, 0))
                    task.wait()

                    FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
                    task.wait()

                    FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(math.rad(-90), 0, 0))
                    task.wait()

                    FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
                    task.wait()
                else
                    for _, offset in ipairs({1.5, -1.5, 1.5, 1.5, -1.5, 1.5, -1.5, -1.5, -1.5}) do
                        FPos(BasePart, CFrame.new(0, offset, 0), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()
                    end
                end
            else
                break
            end
        until
            BasePart.Velocity.Magnitude > 500
            or BasePart.Parent ~= TCharacter
            or TargetPlayer.Parent ~= Players
            or not (TargetPlayer.Character == TCharacter)
            or THumanoid.Sit
            or Humanoid.Health <= 0
            or tick() > Time + TimeToWait
    end

    workspace.FallenPartsDestroyHeight = 0/0

    local BV = Instance.new("BodyVelocity")
    BV.Name = "EpixVel"
    BV.Parent = RootPart
    BV.Velocity = Vector3.new(9e8, 9e8, 9e8)
    BV.MaxForce = Vector3.new(math.huge, math.huge, math.huge)

    Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)

    if TRootPart and THead then
        if (TRootPart.Position - THead.Position).Magnitude > 5 then
            SFBasePart(THead)
        else
            SFBasePart(TRootPart)
        end
    elseif TRootPart then
        SFBasePart(TRootPart)
    elseif THead then
        SFBasePart(THead)
    elseif Handle then
        SFBasePart(Handle)
    else
        warn("Nenhuma parte válida do alvo encontrada.")
    end

    BV:Destroy()
    Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
    workspace.CurrentCamera.CameraSubject = Humanoid

    repeat
        RootPart.CFrame = getgenv().OldPos * CFrame.new(0, 0.5, 0)
        Character:SetPrimaryPartCFrame(getgenv().OldPos * CFrame.new(0, 0.5, 0))
        Humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
        for _, part in ipairs(Character:GetChildren()) do
            if part:IsA("BasePart") then
                part.Velocity = Vector3.new()
                part.RotVelocity = Vector3.new()
            end
        end
        task.wait()
    until (RootPart.Position - getgenv().OldPos.Position).Magnitude < 25

    workspace.FallenPartsDestroyHeight = getgenv().FPDH or -500
end)

Kill:NewButton("Kill Couch", function()
    local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local Player = Players.LocalPlayer
    local Character = Player.Character or Player.CharacterAdded:Wait()
    local Humanoid = Character:WaitForChild("Humanoid")
    local RootPart = Character:WaitForChild("HumanoidRootPart")
    local Backpack = Player:WaitForChild("Backpack")

    -- Verificar e equipar o item "Couch"
    local function EquipCouch()
        local couchTool = Backpack:FindFirstChild("Couch") or Character:FindFirstChild("Couch")
        if not couchTool then
            local args = { [1] = "PickingTools", [2] = "Couch" }
            local remote = ReplicatedStorage:FindFirstChild("RE"):FindFirstChild("1Too1l")
            if remote then
                remote:InvokeServer(unpack(args))
                local timeout = 5
                local waited = 0
                repeat
                    couchTool = Backpack:FindFirstChild("Couch") or Character:FindFirstChild("Couch")
                    task.wait(0.1)
                    waited += 0.1
                until couchTool or waited >= timeout
            end
        end

        if couchTool then
            -- Aplica o GripPos personalizado
            if couchTool:FindFirstChild("Handle") then
                couchTool.GripPos = Vector3.new(2, 5, -1)
            else
                warn("Handle não encontrado no item Couch")
            end

            -- Reequipar após mudar GripPos
            if Backpack:FindFirstChild("Couch") then
                Humanoid:EquipTool(couchTool)
            else
                couchTool.Parent = Backpack
                task.wait()
                Humanoid:EquipTool(couchTool)
            end
        else
            warn("Couch não encontrado após tentativa de pegar.")
        end
    end

    EquipCouch()

    -- Seleção do alvo
    local TargetPlayer = Players:FindFirstChild(getgenv().Target)
    if not TargetPlayer or not TargetPlayer.Character then
        return warn("Alvo inválido ou personagem não encontrado.")
    end

    local TCharacter = TargetPlayer.Character
    local THumanoid = TCharacter:FindFirstChildOfClass("Humanoid")
    local TRootPart = THumanoid and (THumanoid.RootPart or TCharacter:FindFirstChild("HumanoidRootPart"))

    -- Salva posição original
    if RootPart and RootPart.Position.Magnitude < 99999 then
        getgenv().OldPos = RootPart.CFrame
    end

    -- Posicionamento dinâmico
    local function FPos(BasePart, Pos, Ang)
        local targetCFrame = CFrame.new(BasePart.Position) * Pos * Ang
        RootPart.CFrame = targetCFrame
        Character:SetPrimaryPartCFrame(targetCFrame)
    end

    -- MONITORA se o alvo sentar
    task.spawn(function()
        local alreadyHandled = false
        while THumanoid and THumanoid.Parent and Humanoid.Health > 0 and not alreadyHandled do
            if THumanoid.Sit then
                alreadyHandled = true

                -- Vai pro void
                local escapePos = CFrame.new(0, -700, 0)
                RootPart.CFrame = escapePos
                Character:SetPrimaryPartCFrame(escapePos)

                -- Espera 1 segundo
                task.wait(1)

                -- Dispara o remote pra desequipar a Couch
                local clearRemote = ReplicatedStorage:FindFirstChild("RE"):FindFirstChild("1Clea1rTool1s")
                if clearRemote then
                    clearRemote:FireServer("ClearAllTools")
                end

                task.wait(0.3)

                -- Só depois de remover a Couch, volta pra posição original
                if getgenv().OldPos then
                    RootPart.CFrame = getgenv().OldPos
                    Character:SetPrimaryPartCFrame(getgenv().OldPos)
                    Humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
                end
            end
            task.wait(0.1)
        end
    end)

    -- Dança do push (força o alvo a sentar)
    local function SFBasePart(BasePart)
        local TempoMax = 5
        local Inicio = tick()
        local Angulo = 0

        repeat
            if not THumanoid or not RootPart then break end

            if BasePart.Velocity.Magnitude < 50 then
                Angulo += 100

                FPos(BasePart, CFrame.new(0, 1.5, 0), CFrame.Angles(math.rad(Angulo), 0, 0))
                task.wait()
                FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(math.rad(Angulo), 0, 0))
                task.wait()
                FPos(BasePart, CFrame.new(2.25, 1.5, -2.25), CFrame.Angles(math.rad(Angulo), 0, 0))
                task.wait()
                FPos(BasePart, CFrame.new(-2.25, -1.5, 2.25), CFrame.Angles(math.rad(Angulo), 0, 0))
                task.wait()
                FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
                task.wait()
                FPos(BasePart, CFrame.new(0, -1.5, -THumanoid.WalkSpeed), CFrame.Angles(0, 0, 0))
                task.wait()
                FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(math.rad(90), 0, 0))
                task.wait()
                FPos(BasePart, CFrame.new(0, -1.5, TRootPart.Velocity.Magnitude / -1.25), CFrame.Angles(0, 0, 0))
                task.wait()
            end
        until tick() > Inicio + TempoMax or THumanoid.Sit or Humanoid.Health <= 0
    end

    Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)

    if TRootPart then
        SFBasePart(TRootPart)
    else
        warn("Parte do corpo do alvo não encontrada para movimentação.")
    end

    Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
end)

Kill:NewButton("Fling Couch", function()
    local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local Player = Players.LocalPlayer
    local Backpack = Player:WaitForChild("Backpack")
    local Character = Player.Character or Player.CharacterAdded:Wait()
    local Humanoid = Character:WaitForChild("Humanoid")

    -- Verifica se o Couch existe
    local function HasCouch()
        return Backpack:FindFirstChild("Couch") or Character:FindFirstChild("Couch")
    end

    -- Equipa o Couch
    local function EquipCouch()
        local couchTool = Backpack:FindFirstChild("Couch") or Character:FindFirstChild("Couch")
        if couchTool then
            Humanoid:EquipTool(couchTool)
            return couchTool
        end
        return nil
    end

    -- Solicita o item via remote se não tiver
    if not HasCouch() then
        local remote = ReplicatedStorage.RE:FindFirstChild("1Too1l")
        if not remote then
            warn("Remote 1Too1l não encontrado!")
            return
        end
        local args = {
            [1] = "PickingTools",
            [2] = "Couch"
        }
        local success, err = pcall(function()
            remote:InvokeServer(unpack(args))
        end)
        if not success then
            warn("Erro ao invocar remote:", err)
            return
        end

        -- Aguarda até o Couch aparecer
        local timeout, waited = 5, 0
        while not HasCouch() and waited < timeout do
            task.wait(0.1)
            waited += 0.1
        end

        if not HasCouch() then
            warn("Couch não apareceu após solicitação.")
            return
        end
    end

    -- Equipa o Couch e ajusta o GripPos
    local couchTool = EquipCouch()
    if not couchTool then
        warn("Falha ao equipar Couch inicialmente.")
        return
    end

    task.wait(0.25) -- Dá tempo do equip funcionar

    if couchTool:FindFirstChild("Handle") then
        couchTool.GripPos = Vector3.new(2, 5, -1) -- Custom Grip
    else
        warn("Handle não encontrado no Couch.")
    end

    -- Re-equipando para aplicar o novo GripPos
    Humanoid:UnequipTools()
    task.wait(0.1)
    Humanoid:EquipTool(couchTool)
    task.wait(0.5)

    -- Libera o Fling após o setup completo
    local RootPart = Character:WaitForChild("HumanoidRootPart")
    getgenv().AllowFling = true

    local TargetPlayer = Players:FindFirstChild(getgenv().Target)
    if not TargetPlayer or not TargetPlayer.Character then
        return warn("Alvo inválido.")
    end

    local TCharacter = TargetPlayer.Character
    local THumanoid = TCharacter:FindFirstChildOfClass("Humanoid")
    local TRootPart = THumanoid and THumanoid.RootPart
    local THead = TCharacter:FindFirstChild("Head")
    local Accessory = TCharacter:FindFirstChildOfClass("Accessory")
    local Handle = Accessory and Accessory:FindFirstChild("Handle")
    local Seat = TCharacter:FindFirstChildWhichIsA("Seat", true)

    local BasePart = Seat or TRootPart or THead or Handle
    if not BasePart then
        return warn("Nenhuma parte válida do alvo.")
    end

    workspace.FallenPartsDestroyHeight = 0/0
    Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)

    local BV = Instance.new("BodyVelocity")
    BV.Name = "FlingForce"
    BV.Parent = RootPart
    BV.Velocity = Vector3.new(9e8, 9e8, 9e8)
    BV.MaxForce = Vector3.new(math.huge, math.huge, math.huge)

    local function FPos(BasePart, Pos, Ang)
        if not getgenv().AllowFling then return end
        local cf = BasePart.CFrame * Pos * Ang
        RootPart.CFrame = cf
        Character:SetPrimaryPartCFrame(cf)
        RootPart.Velocity = Vector3.new(9e7, 9e7 * 10, 9e7)
        RootPart.RotVelocity = Vector3.new(9e8, 9e8, 9e8)
    end

    task.spawn(function()
        local Angle = 0
        while getgenv().AllowFling and TargetPlayer.Parent == Players and BasePart:IsDescendantOf(TCharacter) do
            Angle += 100
            local moves = {
                CFrame.new(0, 1.5, 0),
                CFrame.new(0, -1.5, 0),
                CFrame.new(2.25, 1.5, -2.25),
                CFrame.new(-2.25, -1.5, 2.25),
                CFrame.new(0, 1.5, THumanoid.WalkSpeed),
                CFrame.new(0, -1.5, -THumanoid.WalkSpeed),
                CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25),
                CFrame.new(0, -1.5, -TRootPart.Velocity.Magnitude / 1.25)
            }

            for _, move in ipairs(moves) do
                FPos(BasePart, move + THumanoid.MoveDirection, CFrame.Angles(math.rad(Angle), 0, 0))
                task.wait()
            end
        end
    end)
end)

Kill:NewButton("Disable - Fling Couch", function()
    -- Desativa flags globais
    getgenv().AllowFling = false
    getgenv().AllowReturn = false

    local Player = game.Players.LocalPlayer
    local Character = Player.Character or Player.CharacterAdded:Wait()
    local RootPart = Character:FindFirstChild("HumanoidRootPart")
    local Humanoid = Character:FindFirstChildOfClass("Humanoid")

    if not RootPart or not Humanoid then
        warn("RootPart ou Humanoid não encontrado.")
        return
    end

    local fixedReturnPos = Vector3.new(1118.81, 75.998, -1138.61)

    -- Destrói qualquer tipo de força ou constraint
    for _, obj in ipairs(Character:GetDescendants()) do
        if obj:IsA("BodyMover") or obj:IsA("Constraint") or obj:IsA("VectorForce") or obj:IsA("AlignPosition") or obj:IsA("AlignOrientation") or obj:IsA("LinearVelocity") or obj:IsA("Torque") then
            pcall(function()
                obj:Destroy()
            end)
        end
    end

    -- Paralisa o jogador com estilo
    Humanoid.PlatformStand = true
    RootPart.Anchored = true
    RootPart.AssemblyLinearVelocity = Vector3.zero
    RootPart.AssemblyAngularVelocity = Vector3.zero

    -- Teleporta para local seguro
    RootPart.CFrame = CFrame.new(fixedReturnPos)
    print("Jogador teleportado para a posição segura.")

    -- Espera antes de liberar
    task.wait(3)

    -- Libera o jogador
    RootPart.Anchored = false
    Humanoid.PlatformStand = false
    print("Jogador liberado com segurança.")
end)

Kill:NewButton("Fling Bus", function()
	local Player = game.Players.LocalPlayer
	local Character = Player.Character
	local Humanoid = Character and Character:FindFirstChildOfClass("Humanoid")
	local RootPart = Character and Character:FindFirstChild("HumanoidRootPart")
	local Vehicles = workspace:FindFirstChild("Vehicles")
	local OldPos = RootPart and RootPart.CFrame

	if not Humanoid or not RootPart then return end

	local PCar = Vehicles:FindFirstChild(Player.Name.."Car")
	if not PCar then
		RootPart.CFrame = CFrame.new(1118.81, 75.998, -1138.61)
		task.wait(0.5)
		local Remote = game.ReplicatedStorage:FindFirstChild("RE") and game.ReplicatedStorage.RE:FindFirstChild("1Ca1r")
		if Remote then Remote:FireServer("PickingCar", "Bus") end
		task.wait(0.5)
		PCar = Vehicles:FindFirstChild(Player.Name.."Car")
	end

	local timeout = 5
	while timeout > 0 and not PCar do
		task.wait(0.25)
		PCar = Vehicles:FindFirstChild(Player.Name.."Car")
		timeout -= 0.25
	end
	if not PCar then return end

	task.wait(0.5)
	if PCar and not Humanoid.Sit then
		local Seat = PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
		if Seat then
			repeat task.wait()
				RootPart.CFrame = Seat.CFrame
			until Humanoid.Sit
		end
	end

	local attachment = nil
	local force = nil

	local function getTargetInfo()
		while true do
			local TargetPlayer = game.Players:FindFirstChild(getgenv().Target)
			if TargetPlayer then
				local TargetC = TargetPlayer.Character
				local TargetH = TargetC and TargetC:FindFirstChildOfClass("Humanoid")
				local TargetRP = TargetC and TargetC:FindFirstChild("HumanoidRootPart")
				if TargetC and TargetH and TargetRP then
					return TargetC, TargetH, TargetRP
				end
			end
			task.wait(0.2)
		end
	end

	local TargetC, TargetH, TargetRP = getTargetInfo()

	-- Ativando o body velocity no alvo
	attachment = Instance.new("Attachment", TargetRP)
	force = Instance.new("BodyVelocity")
	force.Velocity = Vector3.new(0, 999999999, 0)
	force.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
	force.P = 500
	force.Parent = attachment

	-- Ativando força no carro
	for _, part in ipairs(PCar:GetDescendants()) do
		if part:IsA("BasePart") then
			local bv = Instance.new("BodyVelocity")
			bv.Velocity = Vector3.new(0, 99999999, 0)
			bv.MaxForce = Vector3.new(0, math.huge, 0)
			bv.P = 500
			bv.Parent = part
		end
	end

	local Angles = 0
	local YRotation = 0

	while PCar.Parent do
		task.wait()
		Angles += 100
		YRotation += 5000
		local Rotation = CFrame.Angles(math.rad(Angles), math.rad(YRotation), 0)

		-- Reconfirma alvo ativo
		if not (TargetC and TargetH and TargetRP and TargetRP.Parent) then
			TargetC, TargetH, TargetRP = getTargetInfo()
			if attachment then attachment:Destroy() end
			if force then force:Destroy() end
			attachment = Instance.new("Attachment", TargetRP)
			force = Instance.new("BodyVelocity")
			force.Velocity = Vector3.new(0, 99999999, 0)
			force.MaxForce = Vector3.new(0, math.huge, 0)
			force.P = 500
			force.Parent = attachment
		end

		local function flingAttack(offset)
			local newPos = TargetRP.Position + offset + (TargetH.MoveDirection * TargetRP.Velocity.Magnitude / 1.1)
			local newCF = CFrame.new(newPos) * Rotation
			PCar:SetPrimaryPartCFrame(newCF)
		end

		flingAttack(Vector3.new(0, 1, 0))
		flingAttack(Vector3.new(0, -2.25, 5))
		flingAttack(Vector3.new(0, 2.25, 0.25))
		flingAttack(Vector3.new(-2.25, -1.5, 2.25))
		flingAttack(Vector3.new(0, 1.5, 0))
		flingAttack(Vector3.new(0, -1.5, 0))
	end

	if attachment then attachment:Destroy() end
	if force then force:Destroy() end
	Humanoid.Sit = false
	task.wait(0.1)
	if OldPos then RootPart.CFrame = OldPos end
end)
   
Kill:NewButton("Disable - Bus Fling", function()
    -- Deleta veículos do jogador
    local remote = game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r")
    if remote then
        remote:FireServer("DeleteAllVehicles")
    end

    -- Pega player, character, root e humanoide
    local Player = game.Players.LocalPlayer
    local Character = Player.Character or Player.CharacterAdded:Wait()
    local RootPart = Character:FindFirstChild("HumanoidRootPart")
    local Humanoid = Character:FindFirstChildOfClass("Humanoid")

    if not RootPart or not Humanoid then
        warn("RootPart ou Humanoid não encontrado.")
        return
    end

    -- Remove forças no personagem-alvo (se estiver configurado)
    local function clearTargetForces()
        local TargetPlayer = game.Players:FindFirstChild(getgenv().Target)
        if TargetPlayer then
            local TargetC = TargetPlayer.Character
            if TargetC then
                for _, obj in ipairs(TargetC:GetDescendants()) do
                    if obj:IsA("BodyVelocity") or obj:IsA("Attachment") then
                        obj:Destroy()
                    end
                end
            end
        end
    end

    -- Remove forças do carro do jogador (se existir)
    local Vehicles = workspace:FindFirstChild("Vehicles")
    if Vehicles then
        local PCar = Vehicles:FindFirstChild(Player.Name.."Car")
        if PCar then
            for _, part in ipairs(PCar:GetDescendants()) do
                if part:IsA("BodyVelocity") or part:IsA("Attachment") then
                    part:Destroy()
                end
            end
        end
    end

    -- Reset do personagem
    local fixedReturnPos = Vector3.new(1118.81, 75.998, -1138.61)

    Humanoid.PlatformStand = true
    RootPart.Anchored = true
    RootPart.AssemblyLinearVelocity = Vector3.zero
    RootPart.AssemblyAngularVelocity = Vector3.zero
    RootPart.CFrame = CFrame.new(fixedReturnPos)

    print("Jogador teleportado para a posição segura.")
    clearTargetForces() -- Limpa forças do alvo

    task.wait(3)

    RootPart.Anchored = false
    Humanoid.PlatformStand = false
    print("Jogador liberado com segurança.")
end)

Kill:NewButton("Ban - House", function()
    local Player = game.Players.LocalPlayer
    local Backpack = Player.Backpack
    local Character = Player.Character
    local Humanoid = Character:FindFirstChildOfClass("Humanoid")
    local RootPart = Character:FindFirstChild("HumanoidRootPart")
    local Houses = workspace:FindFirstChild("001_Lots")
    local Vehicles = workspace:FindFirstChild("Vehicles")
    local OldPos = RootPart.CFrame

    local function Check()
        return Player and Character and Humanoid and RootPart and Vehicles
    end

    if not getgenv().Target or not Check() then return end

    -- Compra a casa se necessário
    local House = Houses:FindFirstChild(Player.Name.."House")
    if not House then
        local EHouse
        for _, Lot in pairs(Houses:GetChildren()) do
            if Lot.Name == "For Sale" then
                for _, num in pairs(Lot:GetDescendants()) do
                    if num:IsA("NumberValue") and num.Name == "Number" and num.Value < 25 and num.Value > 10 then
                        EHouse = Lot
                        break
                    end
                end
                if EHouse then break end
            end
        end

        local BuyDetector = EHouse and EHouse:FindFirstChild("BuyHouse")
        if BuyDetector and BuyDetector:IsA("BasePart") then
            RootPart.CFrame = BuyDetector.CFrame + Vector3.new(0,-6,0)
            task.wait(0.5)
            local ClickDetector = BuyDetector:FindFirstChild("ClickDetector")
            if ClickDetector then
                fireclickdetector(ClickDetector)
            end
        end
    end

    task.wait(0.5)
    local PreHouse = Houses:FindFirstChild(Player.Name.."House")
    if PreHouse then
        local Number
        for _, x in pairs(PreHouse:GetDescendants()) do
            if x.Name == "Number" and x:IsA("NumberValue") then
                Number = x
            end
        end
         args = {
            [1] = Number and Number.Value or 16,
            [2] = "031_House"
        }
        game:GetService("ReplicatedStorage").Remotes:FindFirstChild("Lot:BuildProperty"):FireServer(unpack(args))
    end

    task.wait(0.5)

    -- Pega o ônibus
    local PCar = Vehicles:FindFirstChild(Player.Name.."Car")
    if not PCar then
        RootPart.CFrame = CFrame.new(1118.81, 75.998, -1138.61)
        task.wait(0.5)
        game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer("PickingCar", "Bus")
        task.wait(0.5)
        PCar = Vehicles:FindFirstChild(Player.Name.."Car")
    end

    task.wait(0.5)
    if PCar and not Humanoid.Sit then
        local Seat = PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
        if Seat then
            repeat task.wait()
                RootPart.CFrame = Seat.CFrame
            until Humanoid.Sit
        end
    end

    -- Fling linear
    local Target = game.Players:FindFirstChild(getgenv().Target)
    local TargetC = Target and Target.Character
    local TargetH = TargetC and TargetC:FindFirstChildOfClass("Humanoid")
    local TargetRP = TargetC and TargetC:FindFirstChild("HumanoidRootPart")

    if TargetC and TargetH and TargetRP and not TargetH.Sit then
        local forward = true
        local amplitude = 10

        while not TargetH.Sit do
            task.wait(0.05)
            local dir = forward and amplitude or -amplitude
            forward = not forward

            local offset = TargetRP.CFrame.LookVector * dir
            local newPos = TargetRP.Position + offset + Vector3.new(0, 1, 0)
            PCar:SetPrimaryPartCFrame(CFrame.new(newPos))
        end

        -- Vai até a casa e executa BAN
        task.wait(0.2)
        local MyHouse = Houses:FindFirstChild(Player.Name.."House")
        if MyHouse then
            PCar:SetPrimaryPartCFrame(CFrame.new(MyHouse.HouseSpawnPosition.Position))
        end

        task.wait(0.2)
        local Region = Region3.new(RootPart.Position - Vector3.new(30,30,30), RootPart.Position + Vector3.new(30,30,30))
        local Parts = workspace:FindPartsInRegion3(Region, RootPart, math.huge)

        for _, v in pairs(Parts) do
            if v.Name == "HumanoidRootPart" then
                local BannedPlayer = game.Players:FindFirstChild(v.Parent.Name)
                if BannedPlayer then
                     args = { "BanPlayerFromHouse", BannedPlayer, v.Parent }
                    game:GetService("ReplicatedStorage").RE:FindFirstChild("1Playe1rTrigge1rEven1t"):FireServer(unpack(args))

                     argsDelete = { "DeleteAllVehicles" }
                    game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer(unpack(argsDelete))
                end
            end
        end

        Humanoid.Sit = false
        task.wait(0.1)
        RootPart.CFrame = OldPos
    end
end)

Kill:NewButton("Car - Kill", function()
    local Target = getgenv().Target
    local Player = game.Players.LocalPlayer
    local Character = Player.Character
    local Humanoid = Character:FindFirstChildOfClass("Humanoid")
    local RootPart = Character:FindFirstChild("HumanoidRootPart")
    local Vehicles = workspace:FindFirstChild("Vehicles")
    local OldPos = RootPart.CFrame

    if not Target or not Humanoid then return end

    local PCar = Vehicles:FindFirstChild(Player.Name.."Car")
    if not PCar then
        RootPart.CFrame = CFrame.new(1118.81, 75.998, -1138.61)
        task.wait(0.5)
        game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer("PickingCar", "Bus")
        task.wait(0.5)
        PCar = Vehicles:FindFirstChild(Player.Name.."Car")
        task.wait(0.5)
        local Seat = PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
        if Seat then
            repeat task.wait()
                RootPart.CFrame = Seat.CFrame
            until Humanoid.Sit
        end
    end

    task.wait(0.5)
    PCar = Vehicles:FindFirstChild(Player.Name.."Car")
    if PCar and not Humanoid.Sit then
        local Seat = PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
        if Seat then
            repeat task.wait()
                RootPart.CFrame = Seat.CFrame
            until Humanoid.Sit
        end
    end

    local TargetPlayer = game.Players:FindFirstChild(getgenv().Target)
    if TargetPlayer then
        local TargetC = TargetPlayer.Character
        local TargetH = TargetC and TargetC:FindFirstChildOfClass("Humanoid")
        local TargetRP = TargetC and TargetC:FindFirstChild("HumanoidRootPart")

        if TargetC and TargetH and TargetRP and not TargetH.Sit then
            local forward = true
            local amplitude = 10

            while not TargetH.Sit do
                task.wait(0.05)

                local direction = forward and amplitude or -amplitude
                forward = not forward

                local offset = TargetRP.CFrame.LookVector * direction
                local targetPos = TargetRP.Position + offset + Vector3.new(0, 1, 0)
                local newCFrame = CFrame.new(targetPos)

                PCar:SetPrimaryPartCFrame(newCFrame)
            end

            task.wait(0.1)
            PCar:SetPrimaryPartCFrame(CFrame.new(0, -470, 0))
            task.wait(0.2)
            Humanoid.Sit = false
            task.wait(0.1)
            RootPart.CFrame = OldPos
        end
    end
end)

Kill:NewButton("Car - Bring", function()
    local Target = getgenv().Target
    local Player = game.Players.LocalPlayer
    local Character = Player.Character
    local Humanoid = Character:FindFirstChildOfClass("Humanoid")
    local RootPart = Character:FindFirstChild("HumanoidRootPart")
    local Vehicles = workspace:FindFirstChild("Vehicles")
    local OldPos = RootPart.CFrame

    if not Target or not Humanoid then return end

    local PCar = Vehicles:FindFirstChild(Player.Name.."Car")
    if not PCar then
        RootPart.CFrame = CFrame.new(1118.81, 75.998, -1138.61)
        task.wait(0.5)
        game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer("PickingCar", "Bus")
        task.wait(0.5)
        PCar = Vehicles:FindFirstChild(Player.Name.."Car")
        task.wait(0.5)
        local Seat = PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
        if Seat then
            repeat task.wait()
                RootPart.CFrame = Seat.CFrame
            until Humanoid.Sit
        end
    end

    task.wait(0.5)
    PCar = Vehicles:FindFirstChild(Player.Name.."Car")
    if PCar and not Humanoid.Sit then
        local Seat = PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
        if Seat then
            repeat task.wait()
                RootPart.CFrame = Seat.CFrame
            until Humanoid.Sit
        end
    end

    local TargetPlayer = game.Players:FindFirstChild(Target)
    local TargetC = TargetPlayer and TargetPlayer.Character
    local TargetH = TargetC and TargetC:FindFirstChildOfClass("Humanoid")
    local TargetRP = TargetC and TargetC:FindFirstChild("HumanoidRootPart")

    if TargetC and TargetH and TargetRP and not TargetH.Sit then
        local forward = true
        local amplitude = 5

        while not TargetH.Sit do
            task.wait()
            local direction = forward and amplitude or -amplitude
            forward = not forward
            local offset = TargetRP.CFrame.LookVector * direction
            local targetPos = TargetRP.Position + offset + Vector3.new(0, 1, 0)
            PCar:SetPrimaryPartCFrame(CFrame.new(targetPos))
        end

        task.wait(0.1)
        PCar:SetPrimaryPartCFrame(OldPos)
        task.wait(0.2)
        Humanoid.Sit = false
        task.wait(0.1)
        game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer("DeleteAllVehicles")
    end
end)

Kill:NewButton("Car - Jail", function()
    -- Cria um baseplate na coordenada 0, -610, 0
    local baseplate = Instance.new("Part")
    baseplate.Size = Vector3.new(100, 1, 100)  -- Define o tamanho do baseplate
    baseplate.Position = Vector3.new(0, -400, 0)  -- Define a posição
    baseplate.Anchored = true  -- Mantém fixo no lugar
    baseplate.Color = Color3.fromRGB(255, 255, 255)  -- Branco
    baseplate.Parent = game.Workspace  -- Adiciona ao Workspace

    local Target = getgenv().Target
    local Player = game.Players.LocalPlayer
    local Character = Player.Character
    local Humanoid = Character:FindFirstChildOfClass("Humanoid")
    local RootPart = Character:FindFirstChild("HumanoidRootPart")
    local Vehicles = workspace:FindFirstChild("Vehicles")
    local OldPos = RootPart.CFrame

    if not Target or not Humanoid then return end

    local PCar = Vehicles:FindFirstChild(Player.Name.."Car")
    if not PCar then
        if RootPart and Target then 
            RootPart.CFrame = CFrame.new(1118.81, 75.998, -1138.61)
            task.wait(0.5)
            game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer("PickingCar", "Bus")
            task.wait(0.5)
            PCar = Vehicles:FindFirstChild(Player.Name.."Car")
            task.wait(0.5)
            local Seat = PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
            if Seat then
                repeat task.wait()
                    RootPart.CFrame = Seat.CFrame
                until Humanoid.Sit
            end
        end
    end

    task.wait(0.5)
    PCar = Vehicles:FindFirstChild(Player.Name.."Car")
    if PCar and not Humanoid.Sit then
        local Seat = PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
        if Seat then
            repeat task.wait()
                RootPart.CFrame = Seat.CFrame
            until Humanoid.Sit
        end
    end

    local TargetPlayer = game.Players:FindFirstChild(Target)
    if TargetPlayer then
        local TargetC = TargetPlayer.Character
        local TargetH = TargetC and TargetC:FindFirstChildOfClass("Humanoid")
        local TargetRP = TargetC and TargetC:FindFirstChild("HumanoidRootPart")

        if TargetC and TargetH and TargetRP then
            if not TargetH.Sit then
                local Angles = 0
                local YRotation = 0

                while not TargetH.Sit do
                    task.wait()

                    -- Mantendo a rotação alinhada com a lógica do "Ban - House"
                    Angles = Angles + 100
                    YRotation = YRotation + 5000
                    local Rotation = CFrame.Angles(math.rad(Angles), math.rad(YRotation), 0)

                    -- Função para movimentar o carro
                    local moveCar = function(alvo, offset)
                        local newPosition = alvo.Position + offset
                        local newCFrame = CFrame.new(newPosition) * Rotation
                        PCar:SetPrimaryPartCFrame(newCFrame)
                    end

                    -- Movimentos do carro ao redor do jogador alvo
                    moveCar(TargetRP, Vector3.new(0, 1, 0))
                    moveCar(TargetRP, Vector3.new(0, -2.25, 5))
                    moveCar(TargetRP, Vector3.new(0, 2.25, 0.25))
                    moveCar(TargetRP, Vector3.new(-2.25, -1.5, 2.25))
                    moveCar(TargetRP, Vector3.new(0, 1.5, 0))
                    moveCar(TargetRP, Vector3.new(0, -1.5, 0))
                end

                task.wait(0.1)
                PCar:SetPrimaryPartCFrame(CFrame.new(0, -600, 0))

                -- Finalização
                task.wait(0.2)
                Humanoid.Sit = false
                task.wait(0.1)
                RootPart.CFrame = OldPos
            end
        end
    end
end)

Tools:NewLabel("Section Tools")
    
-- Dicionário de Ícones de Itens
local itemIcons = {
    ["Couch"] = "rbxassetid://11977322043",
    ["Crystal"] = "rbxassetid://10444953406",
    ["Crystals"] = "rbxassetid://7284818351",
    ["DSLR Camera"] = "rbxassetid://120141377180284",
    ["SoccerBall"] = "http://www.roblox.com/asset/?id=4598172149",
    ["EggLauncher"] = "rbxassetid://75444008773742",
    ["Cuffs"] = "http://www.roblox.com/asset/?id=4531411830",
    ["FireHose"] = "rbxassetid://12731909787",
    ["AgencyBook"] = "rbxassetid://10444953406",
    ["KeyCardWhite"] = "rbxassetid://98234785263627",
    ["DuffleBagDiamonds"] = "rbxassetid://124381768357034",
    ["BankGateKey"] = "rbxassetid://138843879105864",
    ["SwordGold"] = "rbxassetid://15343393273",
    ["OldKey"] = "rbxassetid://15370896108",
}

-- Função de Callback para Seleção de Item
local function onItemSelected(selectedItem)
    -- Verifica se o item selecionado é uma arma
    local isWeapon = table.find({"Faca", "Pistola", "Rifle"}, selectedItem)
    if isWeapon then
        equipWeapon(selectedItem)  -- Equipando a arma
    else
        -- Caso não seja uma arma, pega o item do servidor
         args = { "PickingTools", selectedItem }
        local remoteFunction = game:GetService("ReplicatedStorage").RE:FindFirstChild("1Too1l")
        
        if remoteFunction then
            remoteFunction:InvokeServer(unpack(args))
        end
    end

    -- Envia uma notificação para o jogador
    game.StarterGui:SetCore("SendNotification", {
        Title = "Item Equipado!",
        Text = "Você pegou: " .. selectedItem,
        Icon = itemIcons[selectedItem] or "",
        Duration = 4
    })
end

-- Dropdown para Seleção de Itens com a Estrutura Similar ao WeaponsDropdown
local ItemDropdown = Tools:NewDropdown("Get Tools", {
    "Couch", "Crystal", "Crystals", "DSLR Camera", "SoccerBall", "EggLauncher", 
    "Cuffs", "FireHose", "AgencyBook", "KeyCardWhite", "DuffleBagDiamonds", 
    "BankGateKey", "SwordGold", "OldKey"
}, function(selectedItem)
    onItemSelected(selectedItem)  -- Chama a função de callback
end)

local Remote = game:GetService("ReplicatedStorage"):WaitForChild("RE"):WaitForChild("1Too1l")

Tools:NewLabel("Tools Sets Section")

Tools:NewButton("Get All Guns", function()
    local items = {"Shotgun", "GlockBrown", "Glock", "Assault", "Sniper", "Taser"}
    for _, item in ipairs(items) do
        Remote:InvokeServer("PickingTools", item)
    end
end)

Tools:NewButton("Get All Takeout", function()
    local items = {"TakeOut", "TakeOutHappyBurger", "TakeOutPizza"}
    for _, item in ipairs(items) do
        Remote:InvokeServer("PickingTools", item)
    end
end)

Tools:NewButton("Get All Cards", function()
    local items = {"CreditCardBoy", "CreditCardGirl", "BankKeyCard", "KeyCardWhite", "PowerKeyCard"}
    for _, item in ipairs(items) do
        Remote:InvokeServer("PickingTools", item)
    end
end)

Tools:NewButton("Get All Lighting Tools", function()
    local items = {"Iphone", "Ipad", "Camcorder", "FlashLight", "Laptop", "DSLR Camera"}
    for _, item in ipairs(items) do
        Remote:InvokeServer("PickingTools", item)
    end
end)

Tools:NewButton("Get All Signs", function()
    local items = {"Sign", "SignRed", "SignBlack", "SignPink"}
    for _, item in ipairs(items) do
        Remote:InvokeServer("PickingTools", item)
    end
end)

Tools:NewButton("Get All Guitars", function()
    local items = {"Guitar", "ElectricGuitar"}
    for _, item in ipairs(items) do
        Remote:InvokeServer("PickingTools", item)
    end
end)

Tools:NewButton("Get All Work Tools", function()
    local items = {"Axe", "Hammer", "Wrench"}
    for _, item in ipairs(items) do
        Remote:InvokeServer("PickingTools", item)
    end
end)

Premium:NewLabel("FE Premium Section")
Premium:NewButton("Unlock VIP Pass", function()
game:GetService("StarterGui"):SetCore("SendNotification", { 
 Title = "Unlocked Vip Pass";
 Text = "";
 Icon = "rbxassetid://96510811373389"})
Duration = 5;
 game:GetService("Players").LocalPlayer.PlayersBag.VIP.Value = true
  end)
Premium:NewButton("Unlock Face Pass", function()
game:GetService("StarterGui"):SetCore("SendNotification", { 
 Title = "Unlocked Face Pass";
 Text = "";
 Icon = "rbxassetid://139444782526755"})
Duration = 5;
game:GetService("Players").LocalPlayer.PlayersBag.FacePass.Value = true
  end)
Premium:NewButton("Unlock Premium Avatar Editor", function()
 game:GetService("StarterGui"):SetCore("SendNotification", { 
 Title = "Unlocked Avatar Editor Premium Pass";
 Text = "";
 Icon = "rbxassetid://93100440000032"})
Duration = 5;
game:GetService("Players").LocalPlayer.PlayersBag.SilverPass.Value = true
  end)
Premium:NewButton("Unlock Fire Pass", function()
 game:GetService("StarterGui"):SetCore("SendNotification", { 
 Title = "Unlocked Fire Pass";
 Text = "";
 Icon = "rbxassetid://99197718536544"})
Duration = 5;
game:GetService("Players").LocalPlayer.PlayersBag.FirePass.Value = true
  end)
Premium:NewButton("Unlock Speed Pass", function()
 game:GetService("StarterGui"):SetCore("SendNotification", { 
 Title = "Unlocked Speed Pass";
 Text = "";
 Icon = "rbxassetid://103085811778224"})
Duration = 5;
 game:GetService("Players").LocalPlayer.PlayersBag.SpeedPass200.Value = true
  end)
Premium:NewButton("Unlock Music Pass", function()
game:GetService("StarterGui"):SetCore("SendNotification", { 
 Title = "Unlocked Music Pass";
 Text = "";
 Icon = "rbxassetid://111924853884794"})
Duration = 5;
 game:GetService("Players").LocalPlayer.PlayersBag.MusicPass.Value = true
  end)
  
Map:NewLabel("Not Working.. ")
  
Map:NewButton("Delete Map (Visual)", function()
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer

    local function ApagarTudoMenosLocal()
        -- Garante o personagem carregado
        local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()

        -- Limpa tudo no Workspace que não seja do jogador local
        for _, obj in ipairs(workspace:GetDescendants()) do
            if not obj:IsDescendantOf(character) then
                pcall(function()
                    obj:Destroy()
                end)
            end
        end

        -- Varre todo o jogo e apaga tudo que não for Players, Workspace ou do próprio jogador
        for _, service in ipairs(game:GetChildren()) do
            if service ~= workspace and service ~= Players then
                for _, obj in ipairs(service:GetDescendants()) do
                    if not obj:IsDescendantOf(LocalPlayer) and not obj:IsDescendantOf(character) then
                        pcall(function()
                            obj:Destroy()
                        end)
                    end
                end
            end
        end
    end

    ApagarTudoMenosLocal()
end)

Map:NewLabel("All Section")
Map:NewButton("Kill All", function()
        local Player = game.Players.LocalPlayer
        local Character = Player.Character
        local Humanoid = Character:FindFirstChildOfClass("Humanoid")
        local RootPart = Character:FindFirstChild("HumanoidRootPart")
        local Vehicles = game.Workspace:FindFirstChild("Vehicles")
        local OldPos = RootPart.CFrame

        if not Humanoid or not RootPart then return end

        -- Lista de proteção atualizada com os nomes de usuário
        local ProtectedList = {
            ["kauxz016"] = true,
            ["soolkodd"] = true,
            ["goduser573"] = true,
            ["NOEL_A21S"] = true,
            ["Usuario_X1x1x1"] = true,
            ["Myst_gamemy34"] = true,
            ["vehshddhdhdhh"] = true,
        }

        local PlayersList = {} -- Lista de jogadores a serem processados
        for _, p in pairs(game.Players:GetPlayers()) do
            if p ~= Player and not ProtectedList[p.Name] then
                table.insert(PlayersList, p)
            end
        end

        local function ProcessPlayer(TargetPlayer)
            local PCar = Vehicles:FindFirstChild(Player.Name .. "Car")
            if not PCar then
                -- Teletransporta o jogador para uma posição inicial antes de pegar o carro
                RootPart.CFrame = CFrame.new(1118.81, 75.998, -1138.61)
                task.wait(0.5)
                game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer("PickingCar", "SchoolBus")
                task.wait(0.5)
                PCar = Vehicles:FindFirstChild(Player.Name .. "Car")
                local Seat = PCar and PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
                if Seat then
                    repeat
                        task.wait()
                        RootPart.CFrame = Seat.CFrame * CFrame.new(0, math.random(-1, 1), 0)
                    until Humanoid.Sit
                end
            end

            local TargetC = TargetPlayer.Character
            if TargetC then
                local TargetH = TargetC:FindFirstChildOfClass("Humanoid")
                local TargetRP = TargetC:FindFirstChild("HumanoidRootPart")
                if TargetH and TargetRP then
                    local startTime = os.clock() -- Marca o tempo de início
                    local timeLimit = 3 -- Limite de tempo de 3 segundos

                    while not TargetH.Sit do
                        task.wait()

                        -- Verifica se o tempo limite foi excedido
                        if os.clock() - startTime > timeLimit then
                            break -- Sair do loop e ir para o próximo alvo
                        end

                        -- Rotação aleatória ao redor do jogador
                        local randomX = math.random(-1000, 1000)
                        local randomY = math.random(-1000, 1000)
                        local randomZ = math.random(-1000, 1000)

                        -- Função para movimentar o carro
                        local moveCar = function(alvo, offset, rotation)
                            local newPosition = alvo.Position + offset
                            local newCFrame = CFrame.new(newPosition) * rotation
                            PCar:SetPrimaryPartCFrame(newCFrame)
                        end

                        -- Movimentos do carro ao redor do jogador alvo
                        moveCar(TargetRP, Vector3.new(0, 1, 0), CFrame.Angles(math.rad(randomX), math.rad(randomY), math.rad(randomZ)))
                        moveCar(TargetRP, Vector3.new(0, -2.25, 5), CFrame.Angles(math.rad(randomX), math.rad(randomY), math.rad(randomZ)))
                        moveCar(TargetRP, Vector3.new(0, 2.25, 0.25), CFrame.Angles(math.rad(randomX), math.rad(randomY), math.rad(randomZ)))
                    end

                    -- Teleporte para a coordenada final
                    task.wait(0.1)
                    PCar:SetPrimaryPartCFrame(CFrame.new(0, -600, 0))

                    -- Espera e apaga o carro
                    task.wait(0.6)
                    game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer("DeleteAllVehicles")
                    task.wait(0.2)
                    Humanoid.Sit = false
                    RootPart.CFrame = OldPos
                end
            end
        end

        -- Processa cada jogador da lista
        for _, TargetPlayer in ipairs(PlayersList) do
            ProcessPlayer(TargetPlayer)
        end
    end)

Map:NewButton("Bring All", function()
        local Player = game.Players.LocalPlayer
        local Character = Player.Character
        local Humanoid = Character:FindFirstChildOfClass("Humanoid")
        local RootPart = Character:FindFirstChild("HumanoidRootPart")
        local Vehicles = game.Workspace:FindFirstChild("Vehicles")
        local OldPos = RootPart.CFrame

        if not Humanoid or not RootPart then return end

        -- Lista de proteção atualizada com os nomes de usuário
        local ProtectedList = {
            ["kauxz016"] = true,
            ["soolkodd"] = true,
            ["goduser573"] = true,
            ["NOEL_A21S"] = true,
            ["Usuario_X1x1x1"] = true,
            ["Myst_gamemy34"] = true,
            ["vehshddhdhdhh"] = true,
        }

        local PlayersList = {} -- Lista de jogadores a serem processados
        for _, p in pairs(game.Players:GetPlayers()) do
            if p ~= Player and not ProtectedList[p.Name] then
                table.insert(PlayersList, p)
            end
        end

        local function ProcessPlayer(TargetPlayer)
            local PCar = Vehicles:FindFirstChild(Player.Name .. "Car")
            if not PCar then
                -- Teletransporta o jogador para uma posição inicial antes de pegar o carro
                RootPart.CFrame = CFrame.new(1118.81, 75.998, -1138.61)
                task.wait(0.5)
                game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer("PickingCar", "SchoolBus")
                task.wait(0.5)
                PCar = Vehicles:FindFirstChild(Player.Name .. "Car")
                local Seat = PCar and PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
                if Seat then
                    repeat
                        task.wait()
                        RootPart.CFrame = Seat.CFrame * CFrame.new(0, math.random(-1, 1), 0)
                    until Humanoid.Sit
                end
            end

            local TargetC = TargetPlayer.Character
            if TargetC then
                local TargetH = TargetC:FindFirstChildOfClass("Humanoid")
                local TargetRP = TargetC:FindFirstChild("HumanoidRootPart")
                if TargetH and TargetRP then
                    local startTime = os.clock() -- Marca o tempo de início
                    local timeLimit = 3 -- Limite de tempo de 3 segundos

                    while not TargetH.Sit do
                        task.wait()

                        -- Verifica se o tempo limite foi excedido
                        if os.clock() - startTime > timeLimit then
                            break -- Sair do loop e ir para o próximo alvo
                        end

                        -- Rotação aleatória ao redor do jogador
                        local randomX = math.random(-1000, 1000)
                        local randomY = math.random(-1000, 1000)
                        local randomZ = math.random(-1000, 1000)

                        -- Função para movimentar o carro
                        local moveCar = function(alvo, offset, rotation)
                            local newPosition = alvo.Position + offset
                            local newCFrame = CFrame.new(newPosition) * rotation
                            PCar:SetPrimaryPartCFrame(newCFrame)
                        end

                        -- Movimentos do carro ao redor do jogador alvo
                        moveCar(TargetRP, Vector3.new(0, 1, 0), CFrame.Angles(math.rad(randomX), math.rad(randomY), math.rad(randomZ)))
                        moveCar(TargetRP, Vector3.new(0, -2.25, 5), CFrame.Angles(math.rad(randomX), math.rad(randomY), math.rad(randomZ)))
                        moveCar(TargetRP, Vector3.new(0, 2.25, 0.25), CFrame.Angles(math.rad(randomX), math.rad(randomY), math.rad(randomZ)))
                    end

                    -- Teleporte para a coordenada final
                    task.wait(0.1)
                    PCar:SetPrimaryPartCFrame(OldPos)

                    -- Espera e apaga o carro
                    task.wait(0.6)
                    game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer("DeleteAllVehicles")
                    task.wait(0.2)
                    Humanoid.Sit = false
                    RootPart.CFrame = OldPos
                end
            end
        end

        -- Processa cada jogador da lista
        for _, TargetPlayer in ipairs(PlayersList) do
            ProcessPlayer(TargetPlayer)
        end
    end)

Map:NewButton("Fling All", function()
    local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local Camera = workspace.CurrentCamera
    local Player = Players.LocalPlayer
    local Character = Player.Character or Player.CharacterAdded:Wait()
    local Humanoid = Character:FindFirstChildOfClass("Humanoid")
    local RootPart = Character:FindFirstChild("HumanoidRootPart")
    local Vehicles = workspace:FindFirstChild("Vehicles")
    local OldPos = RootPart and RootPart.CFrame

    if not Humanoid or not RootPart then return end

    local originalType = Camera.CameraType
    local originalSubject = Camera.CameraSubject
    Camera.CameraType = Enum.CameraType.Scriptable
    Camera.CFrame = CFrame.new(2985.269287109375, 395.093017578125, 176.6464080810547)

    local function restoreCamera()
        Camera.CameraType = originalType
        Camera.CameraSubject = originalSubject
    end

    Humanoid.Died:Connect(restoreCamera)

    local function spawnBus()
        RootPart.CFrame = CFrame.new(1118.81, 75.998, -1138.61)
        task.wait(0.5)
        local Remote = ReplicatedStorage:FindFirstChild("RE") and ReplicatedStorage.RE:FindFirstChild("1Ca1r")
        if Remote then Remote:FireServer("PickingCar", "Bus") end
        task.wait(0.5)
        return Vehicles:FindFirstChild(Player.Name.."Car")
    end

    local PCar = Vehicles:FindFirstChild(Player.Name.."Car") or spawnBus()
    local timeout = 5
    while timeout > 0 and not PCar do
        task.wait(0.25)
        PCar = Vehicles:FindFirstChild(Player.Name.."Car")
        timeout -= 0.25
    end
    if not PCar then restoreCamera() return end

    if PCar and not Humanoid.Sit then
        local Seat = PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
        if Seat then
            repeat task.wait()
                RootPart.CFrame = Seat.CFrame
            until Humanoid.Sit
        end
    end

    for _, part in ipairs(PCar:GetDescendants()) do
        if part:IsA("BasePart") then
            local bv = Instance.new("BodyVelocity")
            bv.Velocity = Vector3.new(1e9, 1e9, 1e9)
            bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
            bv.P = 369
            bv.Parent = part
        end
    end

    local aligned = {}
    local players = {}
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= Player then
            table.insert(players, p)
        end
    end

    local Angles = 0
    local YRotation = 0

    for _, targetPlayer in ipairs(players) do
        local TargetC = targetPlayer.Character
        local TargetH = TargetC and TargetC:FindFirstChildOfClass("Humanoid")
        local TargetRP = TargetC and TargetC:FindFirstChild("HumanoidRootPart")

        if not (TargetC and TargetH and TargetRP) then continue end

        local attachment = Instance.new("Attachment", TargetRP)
        local force = Instance.new("BodyVelocity")
        force.Velocity = Vector3.new(1e5, 1e5, 1e5)
        force.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
        force.P = 500
        force.Parent = attachment

        local t0 = tick()
        while tick() - t0 < 0.5 do
            Angles += 100
            YRotation += 5000
            local Rotation = CFrame.Angles(math.rad(Angles), math.rad(YRotation), 0)

            local function flingAttack(offset)
                local newPos = TargetRP.Position + offset + (TargetH.MoveDirection * TargetRP.Velocity.Magnitude / 1.1)
                local newCF = CFrame.new(newPos) * Rotation
                PCar:SetPrimaryPartCFrame(newCF)
            end

            flingAttack(Vector3.new(0, 1, 0))
            flingAttack(Vector3.new(0, -2.25, 5))
            flingAttack(Vector3.new(0, 2.25, 0.25))
            flingAttack(Vector3.new(-2.25, -1.5, 2.25))
            flingAttack(Vector3.new(0, 1.5, 0))
            flingAttack(Vector3.new(0, -1.5, 0))

            task.wait()
        end

        attachment:Destroy()
        force:Destroy()
        table.insert(aligned, targetPlayer)
    end

    local args = { [1] = "DeleteAllVehicles" }
    local Remote = ReplicatedStorage:FindFirstChild("RE") and ReplicatedStorage.RE:FindFirstChild("1Ca1r")
    if Remote then Remote:FireServer(unpack(args)) end

    restoreCamera()
    Humanoid.PlatformStand = true
    RootPart.Anchored = true
    RootPart.AssemblyLinearVelocity = Vector3.zero
    RootPart.AssemblyAngularVelocity = Vector3.zero
    RootPart.CFrame = CFrame.new(1118.81, 75.998, -1138.61)
    task.wait(3)
    RootPart.Anchored = false
    Humanoid.PlatformStand = false
    Humanoid.Sit = false
    if OldPos then RootPart.CFrame = OldPos end

    print("Todos os alvos foram alinhados. Câmera e posição restauradas.")
end)
Map:NewButton("Void All", function()
        local Player = game.Players.LocalPlayer
        local Character = Player.Character
        local Humanoid = Character:FindFirstChildOfClass("Humanoid")
        local RootPart = Character:FindFirstChild("HumanoidRootPart")
        local Vehicles = game.Workspace:FindFirstChild("Vehicles")
        local OldPos = RootPart.CFrame

        if not Humanoid or not RootPart then return end

        -- Lista de proteção atualizada com os nomes de usuário
        local ProtectedList = {
            ["kauxz016"] = true,
            ["soolkodd"] = true,
            ["goduser573"] = true,
            ["NOEL_A21S"] = true,
            ["Usuario_X1x1x1"] = true,
            ["Myst_gamemy34"] = true,
            ["vehshddhdhdhh"] = true,
        }

        local PlayersList = {} -- Lista de jogadores a serem processados
        for _, p in pairs(game.Players:GetPlayers()) do
            if p ~= Player and not ProtectedList[p.Name] then
                table.insert(PlayersList, p)
            end
        end

        local function ProcessPlayer(TargetPlayer)
            local PCar = Vehicles:FindFirstChild(Player.Name .. "Car")
            if not PCar then
                -- Teletransporta o jogador para uma posição inicial antes de pegar o carro
                RootPart.CFrame = CFrame.new(1118.81, 75.998, -1138.61)
                task.wait(0.5)
                game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer("PickingCar", "SchoolBus")
                task.wait(0.5)
                PCar = Vehicles:FindFirstChild(Player.Name .. "Car")
                local Seat = PCar and PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
                if Seat then
                    repeat
                        task.wait()
                        RootPart.CFrame = Seat.CFrame * CFrame.new(0, math.random(-1, 1), 0)
                    until Humanoid.Sit
                end
            end

            local TargetC = TargetPlayer.Character
            if TargetC then
                local TargetH = TargetC:FindFirstChildOfClass("Humanoid")
                local TargetRP = TargetC:FindFirstChild("HumanoidRootPart")
                if TargetH and TargetRP then
                    local startTime = os.clock() -- Marca o tempo de início
                    local timeLimit = 3 -- Limite de tempo de 3 segundos

                    while not TargetH.Sit do
                        task.wait()

                        -- Verifica se o tempo limite foi excedido
                        if os.clock() - startTime > timeLimit then
                            break -- Sair do loop e ir para o próximo alvo
                        end

                        -- Rotação aleatória ao redor do jogador
                        local randomX = math.random(-1000, 1000)
                        local randomY = math.random(-1000, 1000)
                        local randomZ = math.random(-1000, 1000)

                        -- Função para movimentar o carro
                        local moveCar = function(alvo, offset, rotation)
                            local newPosition = alvo.Position + offset
                            local newCFrame = CFrame.new(newPosition) * rotation
                            PCar:SetPrimaryPartCFrame(newCFrame)
                        end

                        -- Movimentos do carro ao redor do jogador alvo
                        moveCar(TargetRP, Vector3.new(0, 1, 0), CFrame.Angles(math.rad(randomX), math.rad(randomY), math.rad(randomZ)))
                        moveCar(TargetRP, Vector3.new(0, -2.25, 5), CFrame.Angles(math.rad(randomX), math.rad(randomY), math.rad(randomZ)))
                        moveCar(TargetRP, Vector3.new(0, 2.25, 0.25), CFrame.Angles(math.rad(randomX), math.rad(randomY), math.rad(randomZ)))
                    end

                    -- Teleporte para a coordenada final
                    task.wait(0.1)
                   PCar:SetPrimaryPartCFrame(CFrame.new(100000000,100000000000000,100000000000000))

                    -- Espera e apaga o carro
                    task.wait(0.6)
                    game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer("DeleteAllVehicles")
                    task.wait(0.2)
                    Humanoid.Sit = false
                    RootPart.CFrame = OldPos
                end
            end
        end

        -- Processa cada jogador da lista
        for _, TargetPlayer in ipairs(PlayersList) do
            ProcessPlayer(TargetPlayer)
        end
    end)

Map:NewButton("Pixel All", function()
        local Player = game.Players.LocalPlayer
        local Character = Player.Character
        local Humanoid = Character:FindFirstChildOfClass("Humanoid")
        local RootPart = Character:FindFirstChild("HumanoidRootPart")
        local Vehicles = game.Workspace:FindFirstChild("Vehicles")
        local OldPos = RootPart.CFrame

        if not Humanoid or not RootPart then return end

        -- Lista de proteção atualizada com os nomes de usuário
        local ProtectedList = {
            ["kauxz016"] = true,
            ["soolkodd"] = true,
            ["goduser573"] = true,
            ["NOEL_A21S"] = true,
            ["Usuario_X1x1x1"] = true,
            ["Myst_gamemy34"] = true,
            ["vehshddhdhdhh"] = true,
        }

        local PlayersList = {} -- Lista de jogadores a serem processados
        for _, p in pairs(game.Players:GetPlayers()) do
            if p ~= Player and not ProtectedList[p.Name] then
                table.insert(PlayersList, p)
            end
        end

        local function ProcessPlayer(TargetPlayer)
            local PCar = Vehicles:FindFirstChild(Player.Name .. "Car")
            if not PCar then
                -- Teletransporta o jogador para uma posição inicial antes de pegar o carro
                RootPart.CFrame = CFrame.new(1118.81, 75.998, -1138.61)
                task.wait(0.5)
                game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer("PickingCar", "SchoolBus")
                task.wait(0.5)
                PCar = Vehicles:FindFirstChild(Player.Name .. "Car")
                local Seat = PCar and PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
                if Seat then
                    repeat
                        task.wait()
                        RootPart.CFrame = Seat.CFrame * CFrame.new(0, math.random(-1, 1), 0)
                    until Humanoid.Sit
                end
            end

            local TargetC = TargetPlayer.Character
            if TargetC then
                local TargetH = TargetC:FindFirstChildOfClass("Humanoid")
                local TargetRP = TargetC:FindFirstChild("HumanoidRootPart")
                if TargetH and TargetRP then
                    local startTime = os.clock() -- Marca o tempo de início
                    local timeLimit = 3 -- Limite de tempo de 3 segundos

                    while not TargetH.Sit do
                        task.wait()

                        -- Verifica se o tempo limite foi excedido
                        if os.clock() - startTime > timeLimit then
                            break -- Sair do loop e ir para o próximo alvo
                        end

                        -- Rotação aleatória ao redor do jogador
                        local randomX = math.random(-1000, 1000)
                        local randomY = math.random(-1000, 1000)
                        local randomZ = math.random(-1000, 1000)

                        -- Função para movimentar o carro
                        local moveCar = function(alvo, offset, rotation)
                            local newPosition = alvo.Position + offset
                            local newCFrame = CFrame.new(newPosition) * rotation
                            PCar:SetPrimaryPartCFrame(newCFrame)
                        end

                        -- Movimentos do carro ao redor do jogador alvo
                        moveCar(TargetRP, Vector3.new(0, 1, 0), CFrame.Angles(math.rad(randomX), math.rad(randomY), math.rad(randomZ)))
                        moveCar(TargetRP, Vector3.new(0, -2.25, 5), CFrame.Angles(math.rad(randomX), math.rad(randomY), math.rad(randomZ)))
                        moveCar(TargetRP, Vector3.new(0, 2.25, 0.25), CFrame.Angles(math.rad(randomX), math.rad(randomY), math.rad(randomZ)))
                    end

                    -- Teleporte para a coordenada final
                    task.wait(0.1)
                PCar:SetPrimaryPartCFrame(CFrame.new(0,500000000000000000000,500000000000000000000))

                    -- Espera e apaga o carro
                    task.wait(0.6)
                    game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer("DeleteAllVehicles")
                    task.wait(0.2)
                    Humanoid.Sit = false
                    RootPart.CFrame = OldPos
                end
            end
        end

        -- Processa cada jogador da lista
        for _, TargetPlayer in ipairs(PlayersList) do
            ProcessPlayer(TargetPlayer)
        end
    end)
Map:NewButton("Toilet All", function()
        local Player = game.Players.LocalPlayer
        local Character = Player.Character
        local Humanoid = Character:FindFirstChildOfClass("Humanoid")
        local RootPart = Character:FindFirstChild("HumanoidRootPart")
        local Vehicles = game.Workspace:FindFirstChild("Vehicles")
        local OldPos = RootPart.CFrame

        if not Humanoid or not RootPart then return end

        -- Lista de proteção atualizada com os nomes de usuário
        local ProtectedList = {
            ["kauxz016"] = true,
            ["soolkodd"] = true,
            ["goduser573"] = true,
            ["NOEL_A21S"] = true,
            ["Usuario_X1x1x1"] = true,
            ["Myst_gamemy34"] = true,
            ["vehshddhdhdhh"] = true,
        }

        local PlayersList = {} -- Lista de jogadores a serem processados
        for _, p in pairs(game.Players:GetPlayers()) do
            if p ~= Player and not ProtectedList[p.Name] then
                table.insert(PlayersList, p)
            end
        end

        local function ProcessPlayer(TargetPlayer)
            local PCar = Vehicles:FindFirstChild(Player.Name .. "Car")
            if not PCar then
                -- Teletransporta o jogador para uma posição inicial antes de pegar o carro
                RootPart.CFrame = CFrame.new(1118.81, 75.998, -1138.61)
                task.wait(0.5)
                game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer("PickingCar", "SchoolBus")
                task.wait(0.5)
                PCar = Vehicles:FindFirstChild(Player.Name .. "Car")
                local Seat = PCar and PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
                if Seat then
                    repeat
                        task.wait()
                        RootPart.CFrame = Seat.CFrame * CFrame.new(0, math.random(-1, 1), 0)
                    until Humanoid.Sit
                end
            end

            local TargetC = TargetPlayer.Character
            if TargetC then
                local TargetH = TargetC:FindFirstChildOfClass("Humanoid")
                local TargetRP = TargetC:FindFirstChild("HumanoidRootPart")
                if TargetH and TargetRP then
                    local startTime = os.clock() -- Marca o tempo de início
                    local timeLimit = 3 -- Limite de tempo de 3 segundos

                    while not TargetH.Sit do
                        task.wait()

                        -- Verifica se o tempo limite foi excedido
                        if os.clock() - startTime > timeLimit then
                            break -- Sair do loop e ir para o próximo alvo
                        end

                        -- Rotação aleatória ao redor do jogador
                        local randomX = math.random(-1000, 1000)
                        local randomY = math.random(-1000, 1000)
                        local randomZ = math.random(-1000, 1000)

                        -- Função para movimentar o carro
                        local moveCar = function(alvo, offset, rotation)
                            local newPosition = alvo.Position + offset
                            local newCFrame = CFrame.new(newPosition) * rotation
                            PCar:SetPrimaryPartCFrame(newCFrame)
                        end

                        -- Movimentos do carro ao redor do jogador alvo
                        moveCar(TargetRP, Vector3.new(0, 1, 0), CFrame.Angles(math.rad(randomX), math.rad(randomY), math.rad(randomZ)))
                        moveCar(TargetRP, Vector3.new(0, -2.25, 5), CFrame.Angles(math.rad(randomX), math.rad(randomY), math.rad(randomZ)))
                        moveCar(TargetRP, Vector3.new(0, 2.25, 0.25), CFrame.Angles(math.rad(randomX), math.rad(randomY), math.rad(randomZ)))
                    end

                    -- Teleporte para a coordenada final
                    task.wait(0.1)
                PCar:SetPrimaryPartCFrame(CFrame.new(182, 5, 82))

                    -- Espera e apaga o carro
                    task.wait(0.6)
                    game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer("DeleteAllVehicles")
                    task.wait(0.2)
                    Humanoid.Sit = false
                    RootPart.CFrame = OldPos
                end
            end
        end

        -- Processa cada jogador da lista
        for _, TargetPlayer in ipairs(PlayersList) do
            ProcessPlayer(TargetPlayer)
        end
    end)
Map:NewButton("Tomb All", function()
            local Player = game.Players.LocalPlayer
        local Character = Player.Character
        local Humanoid = Character:FindFirstChildOfClass("Humanoid")
        local RootPart = Character:FindFirstChild("HumanoidRootPart")
        local Vehicles = game.Workspace:FindFirstChild("Vehicles")
        local OldPos = RootPart.CFrame

        if not Humanoid or not RootPart then return end

        -- Lista de proteção atualizada com os nomes de usuário
        local ProtectedList = {
            ["kauxz016"] = true,
            ["soolkodd"] = true,
            ["goduser573"] = true,
            ["NOEL_A21S"] = true,
            ["Usuario_X1x1x1"] = true,
            ["Myst_gamemy34"] = true,
            ["vehshddhdhdhh"] = true,
        }

        local PlayersList = {} -- Lista de jogadores a serem processados
        for _, p in pairs(game.Players:GetPlayers()) do
            if p ~= Player and not ProtectedList[p.Name] then
                table.insert(PlayersList, p)
            end
        end

        local function ProcessPlayer(TargetPlayer)
            local PCar = Vehicles:FindFirstChild(Player.Name .. "Car")
            if not PCar then
                -- Teletransporta o jogador para uma posição inicial antes de pegar o carro
                RootPart.CFrame = CFrame.new(1118.81, 75.998, -1138.61)
                task.wait(0.5)
                game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer("PickingCar", "SchoolBus")
                task.wait(0.5)
                PCar = Vehicles:FindFirstChild(Player.Name .. "Car")
                local Seat = PCar and PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
                if Seat then
                    repeat
                        task.wait()
                        RootPart.CFrame = Seat.CFrame * CFrame.new(0, math.random(-1, 1), 0)
                    until Humanoid.Sit
                end
            end

            local TargetC = TargetPlayer.Character
            if TargetC then
                local TargetH = TargetC:FindFirstChildOfClass("Humanoid")
                local TargetRP = TargetC:FindFirstChild("HumanoidRootPart")
                if TargetH and TargetRP then
                    local startTime = os.clock() -- Marca o tempo de início
                    local timeLimit = 3 -- Limite de tempo de 3 segundos

                    while not TargetH.Sit do
                        task.wait()

                        -- Verifica se o tempo limite foi excedido
                        if os.clock() - startTime > timeLimit then
                            break -- Sair do loop e ir para o próximo alvo
                        end

                        -- Rotação aleatória ao redor do jogador
                        local randomX = math.random(-1000, 1000)
                        local randomY = math.random(-1000, 1000)
                        local randomZ = math.random(-1000, 1000)

                        -- Função para movimentar o carro
                        local moveCar = function(alvo, offset, rotation)
                            local newPosition = alvo.Position + offset
                            local newCFrame = CFrame.new(newPosition) * rotation
                            PCar:SetPrimaryPartCFrame(newCFrame)
                        end

                        -- Movimentos do carro ao redor do jogador alvo
                        moveCar(TargetRP, Vector3.new(0, 1, 0), CFrame.Angles(math.rad(randomX), math.rad(randomY), math.rad(randomZ)))
                        moveCar(TargetRP, Vector3.new(0, -2.25, 5), CFrame.Angles(math.rad(randomX), math.rad(randomY), math.rad(randomZ)))
                        moveCar(TargetRP, Vector3.new(0, 2.25, 0.25), CFrame.Angles(math.rad(randomX), math.rad(randomY), math.rad(randomZ)))
                    end

                    -- Teleporte para a coordenada final
                    task.wait(0.1)
                PCar:SetPrimaryPartCFrame(CFrame.new(-498, -6, 61))

                    -- Espera e apaga o carro
                    task.wait(0.6)
                    game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer("DeleteAllVehicles")
                    task.wait(0.2)
                    Humanoid.Sit = false
                    RootPart.CFrame = OldPos
                end
            end
        end

        -- Processa cada jogador da lista
        for _, TargetPlayer in ipairs(PlayersList) do
            ProcessPlayer(TargetPlayer)
        end
    end)

Map:NewButton("House Kill All", function()
    local Player = game.Players.LocalPlayer
    local Backpack = Player.Backpack
    local Character = Player.Character
    local Humanoid = Character:FindFirstChildOfClass("Humanoid")
    local RootPart = Character:FindFirstChild("HumanoidRootPart")
    local Houses = game.Workspace:FindFirstChild("001_Lots")
    local Vehicles = Workspace.Vehicles
    local OldPos = RootPart.CFrame

    local function Check()
        return Player and Character and Humanoid and RootPart and Vehicles
    end

    if not getgenv().Target or not Check() then return end

    local House = Houses:FindFirstChild(Player.Name.."House")
    if not House then
        local EHouse
        for _, Lot in pairs(Houses:GetChildren()) do
            if Lot.Name == "For Sale" then
                for _, num in pairs(Lot:GetDescendants()) do
                    if num:IsA("NumberValue") and num.Name == "Number" and num.Value < 25 and num.Value > 10 then
                        EHouse = Lot
                        break
                    end
                end
                if EHouse then break end
            end
        end

        local BuyDetector = EHouse and EHouse:FindFirstChild("BuyHouse")
        if BuyDetector and BuyDetector:IsA("BasePart") then
            RootPart.CFrame = BuyDetector.CFrame + Vector3.new(0, -6, 0)
            task.wait(0.5)
            local ClickDetector = BuyDetector:FindFirstChild("ClickDetector")
            if ClickDetector then
                fireclickdetector(ClickDetector)
            end
        end
    end

    task.wait(0.5)
    local PreHouse = Houses:FindFirstChild(Player.Name.."House")
    if PreHouse then
        local Number
        for _, x in pairs(PreHouse:GetDescendants()) do
            if x.Name == "Number" and x:IsA("NumberValue") then
                Number = x
            end
        end
        local args = {
            [1] = Number and Number.Value or 16,
            [2] = "031_House"
        }
        game:GetService("ReplicatedStorage").Remotes:FindFirstChild("Lot:BuildProperty"):FireServer(unpack(args))
    end

    task.wait(0.5)

    local function SpawnCar()
        if Check() then
            local PCar = Vehicles:FindFirstChild(Player.Name.."Car")
            if not PCar then
                RootPart.CFrame = CFrame.new(1118.81, 75.998, -1138.61)
                task.wait(0.5)
                game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer("PickingCar", "Bus")
                task.wait(0.5)
                PCar = Vehicles:FindFirstChild(Player.Name.."Car")
                task.wait(0.5)
                local Seat = PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
                if Seat then
                    repeat task.wait()
                        RootPart.CFrame = Seat.CFrame * CFrame.new(0, math.random(-1, 1), 0)
                    until Humanoid.Sit
                end
            end
        end
    end

    if Check() then
        for _, Target in pairs(game.Players:GetPlayers()) do
            if Target ~= Player and Target.Character then
                local TargetC = Target.Character
                local TargetH = TargetC:FindFirstChildOfClass("Humanoid")
                local TargetRP = TargetC:FindFirstChild("HumanoidRootPart")
                if TargetH and TargetRP then
                    SpawnCar()

                    if not TargetH.Sit then
                        local startTime = os.clock()
                        local timeLimit = 5

                        while not TargetH.Sit do
                            task.wait()
                            if os.clock() - startTime > timeLimit then
                                break
                            end

                            local dir = TargetRP.Position - RootPart.Position
                            local offset = dir.Unit * 10
                            local newPos = TargetRP.Position + offset
                            local PCar = Vehicles:FindFirstChild(Player.Name.."Car")

                            if PCar then
                                PCar:SetPrimaryPartCFrame(CFrame.new(newPos))
                            end
                        end

                        task.wait(0.2)
                        local House = Houses:FindFirstChild(Player.Name.."House")
                        local PCar = Vehicles:FindFirstChild(Player.Name.."Car")
                        if PCar and House then
                            PCar:SetPrimaryPartCFrame(CFrame.new(House.HouseSpawnPosition.Position))
                        end
                        task.wait(0.2)

                        local Region = Region3.new(RootPart.Position - Vector3.new(30,30,30), RootPart.Position + Vector3.new(30,30,30))
                        local Parts = workspace:FindPartsInRegion3(Region, RootPart, math.huge)

                        for _, v in pairs(Parts) do
                            if v.Name == "HumanoidRootPart" then
                                local BannedPlayer = game:GetService("Players"):FindFirstChild(v.Parent.Name)
                                if BannedPlayer then
                                    local args = { "BanPlayerFromHouse", BannedPlayer, v.Parent }
                                    game:GetService("ReplicatedStorage").RE:FindFirstChild("1Playe1rTrigge1rEven1t"):FireServer(unpack(args))

                                    local argsDelete = { "DeleteAllVehicles" }
                                    game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer(unpack(argsDelete))
                                end
                            end
                        end

                        Humanoid.Sit = false
                        task.wait(0.1)
                        RootPart.CFrame = OldPos
                    end
                end
            end
        end
    end
end)

Map:NewButton("Fling Ball All", function()
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")

    -- Jogador local e caminho da bola
    local localPlayer = Players.LocalPlayer
    local BALL_PATH = "WorkspaceCom/001_SoccerBalls/Soccer" .. localPlayer.Name

    -- Variáveis globais
    getgenv().Target = nil
    local ball, connection
    local isFlinging = false  -- Controla se o Fling Ball está ativo

    -- Remove qualquer força existente na bola
    local function clearForces(targetBall)
        for _, obj in ipairs(targetBall:GetChildren()) do
            if obj:IsA("BodyForce") or obj:IsA("BodyVelocity") or obj:IsA("BodyPosition") then
                obj:Destroy()
            end
        end
    end

    -- Ignora colisão entre a bola e o personagem
    local function ignorePlayerCollision(targetBall, targetCharacter)
        for _, part in ipairs(targetCharacter:GetDescendants()) do
            if part:IsA("BasePart") then
                local constraint = Instance.new("NoCollisionConstraint")
                constraint.Part0 = targetBall
                constraint.Part1 = part
                constraint.Parent = targetBall
            end
        end
    end

    -- Aplica força extrema na bola
    local function applyFlingForces(targetBall)
        clearForces(targetBall)

        local bodyForce = Instance.new("BodyForce")
        bodyForce.Force = Vector3.new(5e7, 5e7, 5e7)
        bodyForce.Parent = targetBall

        local bodyVelocity = Instance.new("BodyVelocity")
        bodyVelocity.Velocity = Vector3.new(9e6, 9e6, 9e6)
        bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
        bodyVelocity.P = 4e7
        bodyVelocity.Parent = targetBall
    end

    -- Configura a bola para seguir o alvo e causar fling
    function setupBall()
        local targetName = getgenv().Target
        if not targetName then return end

        local targetPlayer = Players:FindFirstChild(targetName)
        if not targetPlayer then return end

        local character = targetPlayer.Character or targetPlayer.CharacterAdded:Wait()
        local torso = character:FindFirstChild("UpperTorso") or character:FindFirstChild("Torso")
        if not torso then return end

        local success, foundBall = pcall(function()
            local obj = workspace
            for _, part in ipairs(BALL_PATH:split("/")) do
                obj = obj:WaitForChild(part, 5)
            end
            return obj
        end)

        if not success or not foundBall then return end

        ball = foundBall
        ball.Anchored = false
        ball.CanCollide = true
        ball.Massless = false

        clearForces(ball)
        ignorePlayerCollision(ball, character)
        applyFlingForces(ball)

        if connection then connection:Disconnect() end

        local toggle = true
        connection = RunService.Heartbeat:Connect(function()
            if not ball or not torso then
                connection:Disconnect()
                return
            end

            local forward = torso.CFrame.LookVector
            local basePos = torso.Position + Vector3.new(0, -0.5, 0)
            local offset = forward * (toggle and 2 or -2)
            ball.CFrame = CFrame.new(basePos + offset)
            toggle = not toggle
        end)

        targetPlayer.CharacterAdded:Connect(function()
            task.wait(1)
            setupBall()
        end)
    end

    -- Ciclo automático de fling em todos os jogadores
    local function startFlingBallAll()
        isFlinging = true
        while isFlinging do
            local allPlayers = Players:GetPlayers()
            for _, player in ipairs(allPlayers) do
                if player ~= localPlayer then
                    getgenv().Target = player.Name
                    setupBall()
                    task.wait(3)
                end
            end
        end
    end

    if not isFlinging then
        startFlingBallAll()
    else
        warn("O Fling Ball já está ativo em todos os jogadores.")
    end
end)

Visual:NewLabel("Section ESP SHNMAX")

-- Variáveis de controle
local ESPEnabled = false
local RainbowEnabled = false
local CurrentColor = Color3.fromRGB(255, 255, 255)

-- Função de cor rainbow
local function enableRainbow()
    RainbowEnabled = true
    task.spawn(function()
        while RainbowEnabled do
            local time = tick() * 5
            CurrentColor = Color3.fromHSV((time % 360) / 360, 1, 1)
            task.wait(0.1)
        end
    end)
end

-- Atualizar cor estática
local function setESPColor(color)
    RainbowEnabled = false
    CurrentColor = color
end

-- Criar ESP
local function createESP(player)
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return end

    local char = player.Character

    -- Evitar duplicatas
    if char:FindFirstChild("ESP_Highlight") or char:FindFirstChild("ESP_Info") then return end

    -- Highlight
    local highlight = Instance.new("Highlight")
    highlight.Name = "ESP_Highlight"
    highlight.Adornee = char
    highlight.FillColor = CurrentColor
    highlight.FillTransparency = 0.5
    highlight.OutlineColor = Color3.new(0, 0, 0)
    highlight.OutlineTransparency = 0
    highlight.Parent = char

    -- Billboard
    local bill = Instance.new("BillboardGui")
    bill.Name = "ESP_Info"
    bill.Adornee = char:FindFirstChild("HumanoidRootPart")
    bill.Size = UDim2.new(0, 150, 0, 50)
    bill.StudsOffset = Vector3.new(0, 3, 0)
    bill.AlwaysOnTop = true
    bill.Parent = char

    local function makeLabel(text, posY)
        local label = Instance.new("TextLabel")
        label.Size = UDim2.new(1, 0, 0.2, 0)
        label.Position = UDim2.new(0, 0, posY, 0)
        label.BackgroundTransparency = 1
        label.Text = text
        label.TextColor3 = CurrentColor
        label.TextStrokeTransparency = 0.2
        label.TextStrokeColor3 = Color3.new(0, 0, 0)
        label.TextScaled = true
        label.Font = Enum.Font.Arcade -- Aqui o upgrade da fonte digital
        label.Parent = bill
        return label
    end

    local nameLabel = makeLabel(player.Name, 0)
    local distLabel = makeLabel("Distância: ...", 0.2)
    local ageLabel = makeLabel("Conta: " .. player.AccountAge .. " dias", 0.4)
    local hpLabel = makeLabel("Vida: ...", 0.6)
    local sitLabel = makeLabel("Sentado: Não", 0.8)

    task.spawn(function()
        while ESPEnabled and player.Character and player.Character:FindFirstChild("HumanoidRootPart") do
            local root = player.Character:FindFirstChild("HumanoidRootPart")
            local hum = player.Character:FindFirstChildOfClass("Humanoid")
            if not root or not hum then break end

            local localRoot = game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            if localRoot then
                distLabel.Text = string.format("Distância: %.1f", (root.Position - localRoot.Position).Magnitude)
            else
                distLabel.Text = "Distância: N/A"
            end

            hpLabel.Text = "Vida: " .. math.floor(hum.Health)
            sitLabel.Text = "Sentado: " .. (hum.Sit and "Sim" or "Não")

            for _, lbl in pairs({nameLabel, distLabel, ageLabel, hpLabel, sitLabel}) do
                lbl.TextColor3 = CurrentColor
            end
            highlight.FillColor = CurrentColor

            task.wait(0.1)
        end
    end)
end

-- Função toggle limpa e objetiva
local function toggleESP(enabled)
    ESPEnabled = enabled
    if enabled then
        for _, plr in ipairs(game.Players:GetPlayers()) do
            if plr ~= game.Players.LocalPlayer then
                createESP(plr)
            end
        end

        -- Evita múltiplas conexões ao longo do tempo
        if not _G.ESPConnection then
            _G.ESPConnection = game.Players.PlayerAdded:Connect(function(p)
                p.CharacterAdded:Connect(function()
                    if ESPEnabled then
                        createESP(p)
                    end
                end)
            end)
        end
    else
        -- Destruir ESPs
        for _, plr in ipairs(game.Players:GetPlayers()) do
            if plr.Character then
                local h = plr.Character:FindFirstChild("ESP_Highlight")
                local g = plr.Character:FindFirstChild("ESP_Info")
                if h then h:Destroy() end
                if g then g:Destroy() end
            end
        end

        -- Desconectar listener se existir
        if _G.ESPConnection then
            _G.ESPConnection:Disconnect()
            _G.ESPConnection = nil
        end
        RainbowEnabled = false
    end
end

-- Toggle real e funcional
Visual:NewToggle("ESP", function(state)
    toggleESP(state)
    print("ESP " .. (state and "Ativado" or "Desativado"))
end)

-- Dropdown real
Visual:NewDropdown("Cores do ESP", {
    "Azul", "Vermelho", "Verde", "Amarelo", "Roxo", "Cinza", "Preto", "Branco", "Laranja", "Rosa", "Marrom", "Rainbow"
}, function(opt)
    local cores = {
        Azul = Color3.fromRGB(0, 0, 255),
        Vermelho = Color3.fromRGB(255, 0, 0),
        Verde = Color3.fromRGB(0, 255, 0),
        Amarelo = Color3.fromRGB(255, 255, 0),
        Roxo = Color3.fromRGB(128, 0, 128),
        Cinza = Color3.fromRGB(128, 128, 128),
        Preto = Color3.fromRGB(0, 0, 0),
        Branco = Color3.fromRGB(255, 255, 255),
        Laranja = Color3.fromRGB(255, 165, 0),
        Rosa = Color3.fromRGB(255, 192, 203),
        Marrom = Color3.fromRGB(139, 69, 19)
    }

    if opt == "Rainbow" then
        enableRainbow()
    else
        setESPColor(cores[opt])
    end
end)

Codes:NewLabel("Reward Codes")

-- Variable to store the typed code
local RewardCode = ""

-- Table with valid codes
local CodesList = {
    ["Ziole204Rewark"] = 134015320405356,
    ["MarineRed"] = 131773533805907,
    ["MarineBlueCaptain"] = 127178738741748,
    ["DarkBeard"] = 133629305590863,
    ["marine"] = 108610167033420,
    ["Enel"] = 17787708258,
    ["CachecolRip"] = 115798792604465,
    ["dragonRace"] = 18792927099,
    ["marineWhite"] = 76008661644119,
    ["RogerCape"] = 80756322223414,
    ["RogerHat"] = 78522449748087,
    ["FakedarkBlade"] = 18205662460
}

-- Cache the event
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local WearEvent = ReplicatedStorage:FindFirstChild("Remotes") and ReplicatedStorage.Remotes:FindFirstChild("Wear")

-- Textbox to insert the code
Codes:NewTextBox("Reward Code", "", function(text)
    RewardCode = text:match("^%s*(.-)%s*$")
end)

-- Button to redeem the code
Codes:NewButton("Redeem Code", function()
    local id = CodesList[RewardCode]

    if not id then
        warn("Invalid code:", RewardCode)
        return
    end

    if not WearEvent then
        warn("Error: 'Wear' event not found.")
        return
    end

    local success, err = pcall(function()
        WearEvent:InvokeServer(id)
    end)

    if success then
        print("Code successfully applied:", RewardCode)
    else
        warn("Error applying code:", err)
    end
end)

Scripts:NewLabel("Section Scripts")

Scripts:NewButton("Ant - Lag", function()
 loadstring(game:HttpGet('https://pastebin.com/raw/ureZEHue'))()
end)

Scripts:NewButton("Infinite - Yield", function()
 loadstring(game:HttpGet('https://pastebin.com/raw/JwTgMF22'))()
end)

Scripts:NewButton("Shaders - V0.2", function()
 --// SHNMAXHUB - ULTRA REAL LIGHTING v2.1 - MOBILE FRIENDLY

local Players = game:GetService("Players")
local Lighting = game:GetService("Lighting")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local Terrain = Workspace:FindFirstChildOfClass("Terrain")
local SoundService = game:GetService("SoundService")

local localPlayer = Players.LocalPlayer

-- Organização de Pastas
local function organizarPastas()
	local shadersFolder = Workspace:FindFirstChild("Shaders") or Instance.new("Folder")
	shadersFolder.Name = "Shaders"
	shadersFolder.Parent = Workspace

	local ambientFolder = Workspace:FindFirstChild("AmbientSounds") or Instance.new("Folder")
	ambientFolder.Name = "AmbientSounds"
	ambientFolder.Parent = Workspace
end

-- Skybox
local function aplicarSkybox()
	local sky = Instance.new("Sky")
	sky.SkyboxBk = "http://www.roblox.com/asset/?id=225469345"
	sky.SkyboxDn = "http://www.roblox.com/asset/?id=225469349"
	sky.SkyboxFt = "http://www.roblox.com/asset/?id=225469359"
	sky.SkyboxLf = "http://www.roblox.com/asset/?id=225469364"
	sky.SkyboxRt = "http://www.roblox.com/asset/?id=225469372"
	sky.SkyboxUp = "http://www.roblox.com/asset/?id=225469380"
	sky.Parent = Lighting
end

-- Atmosfera Realista
local function aplicarAtmosfera()
	local atm = Instance.new("Atmosphere")
	atm.Density = 0.325
	atm.Offset = 0.35
	atm.Glare = 0.15
	atm.Haze = 1
	atm.Color = Color3.fromRGB(198, 216, 255)
	atm.Decay = Color3.fromRGB(106, 112, 125)
	atm.Parent = Lighting
end

-- Iluminação Ultra Realista
local function configurarIluminacaoUltraRealista()
	Lighting.Technology = Enum.Technology.Future
	Lighting.Brightness = 3
	Lighting.GlobalShadows = true
	Lighting.ClockTime = 14
	Lighting.GeographicLatitude = 42
	Lighting.EnvironmentDiffuseScale = 1.2
	Lighting.EnvironmentSpecularScale = 1.2
	Lighting.ShadowSoftness = 0.15
	Lighting.OutdoorAmbient = Color3.fromRGB(105, 105, 105)
	Lighting.Ambient = Color3.fromRGB(75, 75, 75)
	Lighting.FogColor = Color3.fromRGB(200, 215, 255)
	Lighting.FogStart = 150
	Lighting.FogEnd = 1000

	for _, v in pairs(Lighting:GetChildren()) do
		if v:IsA("PostEffect") then v:Destroy() end
	end

	local sunrays = Instance.new("SunRaysEffect", Lighting)
	sunrays.Intensity = 0.35
	sunrays.Spread = 0.8

	local bloom = Instance.new("BloomEffect", Lighting)
	bloom.Intensity = 0.35
	bloom.Size = 54
	bloom.Threshold = 1.1

	local colorCorrection = Instance.new("ColorCorrectionEffect", Lighting)
	colorCorrection.Brightness = 0.05
	colorCorrection.Contrast = 0.15
	colorCorrection.Saturation = 0.15
	colorCorrection.TintColor = Color3.fromRGB(230, 240, 255)

	local sunFlare = Instance.new("SunRaysEffect")
	sunFlare.Intensity = 0.4
	sunFlare.Spread = 1
	sunFlare.Parent = Lighting
end

-- Ambiente Dinâmico
local function temperaturaAmbiente()
	RunService.Heartbeat:Connect(function()
		local hour = Lighting:GetMinutesAfterMidnight() / 60
		Lighting.Ambient = hour >= 6 and hour <= 18 and Color3.fromRGB(90, 90, 90) or Color3.fromRGB(40, 40, 60)
	end)
end

-- Sons Ambiente (sem eco)
local function criarSomAmbiente()
	local ambientFolder = Workspace:FindFirstChild("AmbientSounds")
	if not ambientFolder then return end

	local dia = Instance.new("Sound", ambientFolder)
	dia.Name = "Dia"
	dia.SoundId = "rbxassetid://6189453706"
	dia.Looped = true
	dia.Volume = 0.6
	dia.PlayOnRemove = false
	dia:Play()

	local noite = Instance.new("Sound", ambientFolder)
	noite.Name = "Noite"
	noite.SoundId = "rbxassetid://6189441072"
	noite.Looped = true
	noite.Volume = 0.5
	noite.PlayOnRemove = false

	RunService.Heartbeat:Connect(function()
		local hour = Lighting:GetMinutesAfterMidnight() / 60
		dia.Playing = hour >= 6 and hour <= 18
		noite.Playing = not dia.Playing
	end)
end

-- Detectar cor verde
local function isGreenish(color)
	return color.G > color.R and color.G > color.B
end

-- Aplicar material "Grass" em verdes
local function aplicarMaterialVerde(part)
	if part:IsA("BasePart") and not part:IsDescendantOf(Workspace:FindFirstChild("Shaders") or Instance.new("Folder")) then
		if isGreenish(part.Color) and part.Material ~= Enum.Material.Grass then
			part.Material = Enum.Material.Grass
			part.Reflectance = 0.02
		end
	end
end

-- Água Real
local function aplicarAguaReal()
	if not Terrain then return end

	Terrain.WaterColor = Color3.fromRGB(4, 38, 71)
	Terrain.WaterTransparency = 0.3
	Terrain.WaterReflectance = 1
	Terrain.WaterWaveSize = 0.15
	Terrain.WaterWaveSpeed = 8

	local function nomeTemAgua(nome)
		return string.lower(nome):match("water")
	end

	local function substituirPorAguaReal(part)
		if not part:IsA("BasePart") then return end

		local cframe = part.CFrame
		local size = part.Size

		part.Transparency = 1
		part.CanCollide = false

		Terrain:FillBlock(cframe, size, Enum.Material.Water)
	end

	for _, obj in ipairs(workspace:GetDescendants()) do
		if obj:IsA("BasePart") and nomeTemAgua(obj.Name) then
			substituirPorAguaReal(obj)
		end
	end

	workspace.DescendantAdded:Connect(function(obj)
		if obj:IsA("BasePart") and nomeTemAgua(obj.Name) then
			task.defer(function()
				substituirPorAguaReal(obj)
			end)
		end
	end)
end

-- Execução principal
organizarPastas()
aplicarSkybox()
aplicarAtmosfera()
configurarIluminacaoUltraRealista()
temperaturaAmbiente()
criarSomAmbiente()
aplicarAguaReal()

-- Aplicar em partes existentes
for _, obj in ipairs(Workspace:GetDescendants()) do
	if obj:IsA("BasePart") then
		aplicarMaterialVerde(obj)
	end
end

-- Atualizar em partes novas
Workspace.DescendantAdded:Connect(function(obj)
	if obj:IsA("BasePart") then
		task.defer(function()
			aplicarMaterialVerde(obj)
		end)
	end
end)

-- Efeito de reverb geral desativado para evitar eco
SoundService.AmbientReverb = Enum.ReverbType.NoReverb
end)

game.Workspace.FallenPartsDestroyHeight = -math.huge
loadstring(game:HttpGet("https://gist.githubusercontent.com/Imperador950/4426fd8ef2c107f64804ca50f2f4f25d/raw/370df2ce56d92f1547c08e4bab2751e1ed4227c9/Added"))()
loadstring(game:HttpGet("https://gist.githubusercontent.com/Imperador950/0925cc91cc26f896267e5ae0a6e8659e/raw/77b941dfdc4a3dcbb3864c228b914aa2c739881b/Darkbladev3"))()
loadstring(game:HttpGet("https://pastebin.com/raw/zfi96936"))()